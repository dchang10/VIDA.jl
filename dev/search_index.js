var documenterSearchIndex = {"docs":
[{"location":"api/function_index/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/function_index/","page":"API","title":"API","text":"CurrentModule = VIDA","category":"page"},{"location":"api/function_index/#Contents","page":"API","title":"Contents","text":"","category":"section"},{"location":"api/function_index/","page":"API","title":"API","text":"Pages = [\"function_index.md\"]","category":"page"},{"location":"api/function_index/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/function_index/","page":"API","title":"API","text":"Pages = [\"function_index.md\"]","category":"page"},{"location":"api/function_index/#Filters","page":"API","title":"Filters","text":"","category":"section"},{"location":"api/function_index/","page":"API","title":"API","text":"These are the various filter types and helper functions.","category":"page"},{"location":"api/function_index/","page":"API","title":"API","text":"VIDA.AbstractFilter\nVIDA.AbstractImageFilter\nImageFilter\nLogSpiral\nConstant\nDisk\nAsymGaussian\nGaussianRing\nSlashedGaussianRing\nEllipticalGaussianRing\nTIDAGaussianRing\nGeneralGaussianRing\nCosineRing\nAddFilter\nMulFilter\nBase.size(f::T) where {T<:AbstractFilter}\nunpack\nstack\nsplit\nVIDA.filter_image","category":"page"},{"location":"api/function_index/#VIDA.AbstractFilter","page":"API","title":"VIDA.AbstractFilter","text":"abstract type AbstractFilter\n\nAn abstract type that defines super filter type.\n\n\n\n\n\n","category":"type"},{"location":"api/function_index/#VIDA.AbstractImageFilter","page":"API","title":"VIDA.AbstractImageFilter","text":"abstract type AbstractImageFilter <: VIDA.AbstractFilter\n\nAn abstract type that will contain the filter information, such as the parameters. Specific instanstantiations will need to be defined for you to use this.\n\nDetails\n\nThis defined the highest function type. If you wish to implement your own filter you\nneed to define a a couple of things\n1. The filter type <: AbstractFilter\n2. an functor of the type that computes the filter function\n3. an `Base.size` function that defines the number of parameters of the filter.\n\nAn example is given by:\n\n#All of our composite type are defined using the Paramters.jl package to you\ncan directly refer to the struct parameters when creating it, although this isn't\nactually used anywhere in the code.\n@with_kw struct Gaussian <: AbstractFilter\n    σ::Float64\n    x0::Float64\n    y0::Float64\nend\n\n#Typically we inline and force the function to use fastmath\n@fastmath @inline function (θ::Gaussian)(x,y)\n    return 1.0/(2π*σ^2)*exp(-0.5*( (x-x0)^2+(y-y0)^2 ) )\nend\nBase.size(::Type{Gaussian}) = 3\n\n\n\n\n\n","category":"type"},{"location":"api/function_index/#VIDA.ImageFilter","page":"API","title":"VIDA.ImageFilter","text":"Type for an image filter. This takes an EHTImage or any image object and creates a filter out of it. The parameters of the image are the center of the image x0, y0.\n\nFields\n\nx0\ny0\n\n\n\n\n\n","category":"type"},{"location":"api/function_index/#VIDA.LogSpiral","page":"API","title":"VIDA.LogSpiral","text":"Filter type for a logarithmic spiral segment\n\nFields\n\nr0\nRadius of the spiral peak brightness\nκ\nUnit curvature of the logarithmic spiral\nσ\nthickness of the Gaussian spiral arm\nδϕ\nAzimuthal extent of the spiral arm\nξ\npeak brightness location\nx0\nx location of disk center in μas\ny0\ny location of disk center in μas\n\n\n\n\n\n","category":"type"},{"location":"api/function_index/#VIDA.Constant","page":"API","title":"VIDA.Constant","text":"struct Constant <: VIDA.AbstractFilter\n\nAn constant filter.\n\nDetails\n\nDefines an image that just has constant flux. This is very useful for soaking up low levels of flux in image reconstructions that can bias the results.\n\nSince images or normalized to unity, this means the Constant filter has no additional parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/function_index/#VIDA.Disk","page":"API","title":"VIDA.Disk","text":"struct Disk <: VIDA.AbstractFilter\n\nA smoothed disk model\n\nDetails\n\nDefines a filter for an image that has a smoothed disk model.\n\n\n\n\n\n","category":"type"},{"location":"api/function_index/#VIDA.AsymGaussian","page":"API","title":"VIDA.AsymGaussian","text":"struct AsymGaussian <: VIDA.AbstractFilter\n\nAn asymmetric Gaussian blob.\n\nDetails\n\nDefines a asymmetric Gaussian image. This is useful if the image has some non-ring emission in the and you need to soak up some of the flux.\n\nThe parameters of the model follow very closely to those used in Themis. The Gaussian size σ is given by     σ = √(σxσy)     τ = 1-σy/σx, where σx,σy are the semi-major,minor axis lenght respectively. This is similar to how the asymmetry for the EllipticalGaussianRing.\n\nFields\n\nσ\nGaussian size in μas\nτ\nGaussian asymmetry\nξ\nGaussian orientation in radians measured north of east\nx0\nx position of Gaussian center in μas\ny0\ny position of Gaussian center in μas\n\n\n\n\n\n","category":"type"},{"location":"api/function_index/#VIDA.GaussianRing","page":"API","title":"VIDA.GaussianRing","text":"struct GaussianRing <: VIDA.AbstractFilter\n\nSymmetric gaussian ring filter. This is the most basic filter and just attempts to recover a location x0,y0, radius r0 and thickness σ from some image.\n\nFields\n\nr0\nRadius of Gaussian ring in μas\nσ\nStandard deviation of Gaussian ring in μas\nx0\nx location of the center of the Gaussian ring in μas\ny0\ny location of the center of the Gaussian ring in μas\n\nExample\n\nGaussianRing(r0=20.0,σ=5.0,x0=0.0,y0=-10.0)\n\n\n\n\n\n","category":"type"},{"location":"api/function_index/#VIDA.SlashedGaussianRing","page":"API","title":"VIDA.SlashedGaussianRing","text":"struct SlashedGaussianRing <: VIDA.AbstractFilter\n\nImplements the slashed gaussian ring filter, that uses a cosine to symmetrically implement the slash. While this is marginally more complicated that a linear slash, it has a number of benefits such as mainting the azimuthal and smooth structure of the image.\n\nFields\n\nr0\nRadius of the ring in μas\nσ\nStandard deviation of Gaussian ring in μas\ns\nSlash strength of Gaussiang ring. 0 means no slash\nξ\nRotation angle in radians of slash direction, measured north of west\nx0\nx position of the center of the ring in μas\ny0\ny position of the center of the ring in μas\n\n\n\n\n\n","category":"type"},{"location":"api/function_index/#VIDA.EllipticalGaussianRing","page":"API","title":"VIDA.EllipticalGaussianRing","text":"struct EllipticalGaussianRing <: VIDA.AbstractFilter\n\nImplements the elliptical gaussian ring filter. Where the ellipticity tau is defined as one minus ratio between the semi-minor and semi-major axis.\n\nDetails\n\nAdds ellipticity to the ring. The radius r0 of the ring is now defined as the geometric mean of the semi-major (a) and semi-minor (b) axis lengths i.e.\n\nr0 = √(a*b).\n\nThe ellipticity τ is given by τ = 1-b/a.\n\nFields\n\nr0\nRadius of the Gaussian ring\nσ\nStandard deviation of the width of the Gaussian ring\nτ\nAsymmetry of the Gaussian ring defined as 1-ba\nξ\nAsymmetry orientation in radians measured north of east\nx0\nx position of the center of the ring in μas\ny0\ny position of the center of the ring in μas\n\nNotes\n\nThere is no normalization since the ellipticity makes it impossible to normalize analytically. In fact the distance from the ellipse is implemented numerically using an algorithm adapted from git\n\n\n\n\n\n","category":"type"},{"location":"api/function_index/#VIDA.TIDAGaussianRing","page":"API","title":"VIDA.TIDAGaussianRing","text":"struct TIDAGaussianRing <: VIDA.AbstractFilter\n\nCreates the filter from the Paper I am writing. It is a combination of the elliptical and slashed gaussian ring. The slash and the semi-major axis are either aligned if the slash parameter s>0 or antialigned if s<0.\n\nDetails\n\nAdds ellipticity to the ring. The radius r0 of the ring is now defined as the geometric mean of the semi-major (a) and semi-minor (b) axis lengths i.e.\n\nr0 = √(a*b).\n\nThe ellipticity τ is given by τ = 1-b/a.\n\nFields\n\nr0\nRadius of the Gaussian ring\nσ\nStandard deviation of the width of the Gaussian ring\nτ\nAsymmetry of the Gaussian ring defined as 1-ba\ns\nSlash of Gaussian ring.\nξ\nSlash/Asymmetry orientation in radians measured north of east\nx0\nx position of the center of the ring in μas\ny0\ny position of the center of the ring in μas\n\n\n\n\n\n","category":"type"},{"location":"api/function_index/#VIDA.GeneralGaussianRing","page":"API","title":"VIDA.GeneralGaussianRing","text":"struct GeneralGaussianRing <: VIDA.AbstractFilter\n\nCreates the most general elliptical slashed gaussian ring model. It is a combination of the elliptical and slashed gaussian ring. The direction of the slash and the ellipticity are not aligned or anti-aligned like with the TIDAGaussianRing type.\n\nDetails\n\nAdds ellipticity to the ring. The radius r0 of the ring is now defined as the geometric mean of the semi-major (a) and semi-minor (b) axis lengths i.e.\n\nr0 = √(a*b).\n\nThe ellipticity τ is given by τ = 1-b/a.\n\nFields\n\nr0\nRadius of the Gaussian ring\nσ\nStandard deviation of the width of the Gaussian ring\nτ\nAsymmetry of the Gaussian ring defined as 1-ba\nξτ\nAsymmetry orientation in radians, measured north of east\ns\nSlash of Gaussian ring.\nξs\nSlash orientation in radians measured north of east\nx0\nx position of the center of the ring in μas\ny0\ny position of the center of the ring in μas\n\n\n\n\n\n","category":"type"},{"location":"api/function_index/#VIDA.CosineRing","page":"API","title":"VIDA.CosineRing","text":"struct CosineRing{N, M} <: VIDA.AbstractFilter\n\nExtrememly flexible ring model. The thickness is modeled as a cosine expansion with N terms and the slash by a expansion with M terms.\n\nDetails\n\nThe ring is allowed to be elliptical. The thickness of the ring is modeled by a cosine expansion in azimuthal angle. N specifies the number of cosine modes to fit, where the first mode is the constant thickness portion and so has no corresponding angle. The slash is modeled as a separate cosine expansion, with M terms. Here the zero order term is forced to be unity, so M defines the M additional terms.\n\n\n\n\n\n","category":"type"},{"location":"api/function_index/#VIDA.AddFilter","page":"API","title":"VIDA.AddFilter","text":"struct AddFilter{T1<:VIDA.AbstractFilter, T2<:VIDA.AbstractFilter} <: VIDA.AbstractFilter\n\nCombines two filters together into one object. Since addition is assoiciative this can actually we used to hold multiple different filters.\n\nDetails\n\nOverloads the Base.:+ function so you can easily add two filters together.\n\nExample\n\nθ1 = GaussianRing(10,5,0,0)\nθ2 = SlashedGaussianRing(15,5,0.5,π/4,0,0)\nθ12 = θ1+θ2\n\n\n\n\n\n","category":"type"},{"location":"api/function_index/#VIDA.MulFilter","page":"API","title":"VIDA.MulFilter","text":"struct MulFilter{T<:VIDA.AbstractFilter, S<:Number} <: VIDA.AbstractFilter\n\nMultiplies filter by a constant. This is useful when combining with AddFilter since it will change the relative weights of each filter.\n\nDetails\n\nOverloads the Base.:* function so you can easily multiple a filter by a number.\n\nExample\n\nθ = GaussianRing(15,5,0.0,0.0)\n2*θ\n\n\n\n\n\n","category":"type"},{"location":"api/function_index/#Base.size-Tuple{T} where T<:VIDA.AbstractFilter","page":"API","title":"Base.size","text":"size(f::AbstractFilter)\n\nGet the number of parameters for the filter f\n\n\n\n\n\n","category":"method"},{"location":"api/function_index/#VIDA.unpack","page":"API","title":"VIDA.unpack","text":"unpack(θinit)\n\n\nUnpacks the parameters of the filter θ\n\nReturns the parameters in a vector.\n\n\n\n\n\n","category":"function"},{"location":"api/function_index/#VIDA.stack","page":"API","title":"VIDA.stack","text":"stack(θ, θ1)\n\n\nStacks filters together so you can easily combine multiple filters. It does this by calling the :+ and :* method. Every filter added will include an additional parameter that controls the relative weight of each filter.\n\n\n\n\n\n","category":"function"},{"location":"api/function_index/#Base.split","page":"API","title":"Base.split","text":"split(θ)\n\n\nSplits the filter into an array with its subcomponents so you can easily access them.\n\n\n\n\n\n","category":"function"},{"location":"api/function_index/#VIDA.filter_image","page":"API","title":"VIDA.filter_image","text":"filter_image(θ, npix, xlim, ylim)\n\n\nCreates an npix×npix rasterized image of the filter θ with limits xlim and ylim\n\nReturns the tuple (xitr,yitr,image) where xitr,yitr are the iterators defining the pixel locations (which are centered) and the rasterized image,  in Jy/μas^2.\n\nNote\n\nI use the pixel size definition fieldofview/npix, but the image is evaluated at the pixel centers.\n\nWe also use the astronomer orientation and ordering.\n\n\n\n\n\n","category":"function"},{"location":"api/function_index/#Images","page":"API","title":"Images","text":"","category":"section"},{"location":"api/function_index/","page":"API","title":"API","text":"VIDA has an image interface that reads in images using the FITS standard.","category":"page"},{"location":"api/function_index/","page":"API","title":"API","text":"AbstractImage\nAbstractFitsImage\nEHTImage\nload_fits\nsave_fits\ncentroid\ninertia\npixelloc\nflux(::EHTImage)\nrescale(::EHTImage, ::Any, ::Any, ::Any)\nblur(::EHTImage, ::Any)\nBase.size(img::EHTImage)\nclipimage\nfield_of_view","category":"page"},{"location":"api/function_index/#VIDA.AbstractImage","page":"API","title":"VIDA.AbstractImage","text":"An abstact type that acts as a wrapper for image objects used in astronomy.\n\nThis is the top of the castle for images and will be rarely touched. Basically unless you don't want to use fits images this will not be used\n\n\n\n\n\n","category":"type"},{"location":"api/function_index/#VIDA.AbstractFitsImage","page":"API","title":"VIDA.AbstractFitsImage","text":"An absract image that will hold a fits image after being created or parsed in. This will form the basis for most astronomical images that are defined.\n\nThe defines an interface to the FITS image methods below. In the future I may change this to use the traits interfaces.\n\n\n\n\n\n","category":"type"},{"location":"api/function_index/#VIDA.EHTImage","page":"API","title":"VIDA.EHTImage","text":"struct EHTImage{F, T<:AbstractArray{F,2}} <: VIDA.AbstractFitsImage{F,T<:AbstractArray{F,2}}\n\nDetails\n\nThe trait is to hold a EHT image tyically in matrix form. Namely the trait will typically be Matrix{Float64}.\n\nnx is the number of pixels in the x or RA direction ny is the number of pixels in the y or DEC direction psize_x, psize_y are the pixel sizes in the x and y direction source is the source we are looking at e.g. M87 ra,dec are the sources RA and DEC in J2000 coordinates using degrees wavelength is the wavelength of the image. mjd is the Modified Julian Date of the observation. img is the actual pixeled image in Jy/pixel\n\n\n\n\n\n","category":"type"},{"location":"api/function_index/#VIDA.load_fits","page":"API","title":"VIDA.load_fits","text":"load_fits(fits_name)\n\n\nwhere fits_name should be a fits file generated using ehtim\n\nDetails\n\nThis reads in a fits file that is more robust to the various imaging algorithms in the EHT, i.e. is works with clean, smili, eht-imaging.\n\nThe function returns an EHTImage object that contains the relevant image and parameters extracted from the fits file. It also ensures that we are astronomers and that the image using sky-left coordinates.\n\n\n\n\n\n","category":"function"},{"location":"api/function_index/#VIDA.save_fits","page":"API","title":"VIDA.save_fits","text":"save_fits(image::EHTImage, fname::String)\n\nSave the image as a fits object with filename fname\n\n\n\n\n\n","category":"function"},{"location":"api/function_index/#VIDA.centroid","page":"API","title":"VIDA.centroid","text":"centroid(img)\n\n\nFinds the centroid or center of light of the img in μas.\n\n\n\n\n\n","category":"function"},{"location":"api/function_index/#VIDA.inertia","page":"API","title":"VIDA.inertia","text":"inertia(img)\ninertia(img, center)\n\n\nFind the image moment of inertia or second moment\n\nNotes\n\nIf center=true then we find the central second moment, or the second cumulant of the image.\n\n\n\n\n\n","category":"function"},{"location":"api/function_index/#VIDA.pixelloc","page":"API","title":"VIDA.pixelloc","text":"pixelloc(img)\n\n\nReturns two iterators (ra,dec) that give the locations of the img pixels.\n\n\n\n\n\n","category":"function"},{"location":"api/function_index/#VIDA.flux-Tuple{EHTImage}","page":"API","title":"VIDA.flux","text":"flux(img)\n\n\nFinds the image flux of an EHTImage img\n\n\n\n\n\n","category":"method"},{"location":"api/function_index/#VIDA.rescale-Tuple{EHTImage,Any,Any,Any}","page":"API","title":"VIDA.rescale","text":"rescale(img::EHTImage, npix, xlim, ylim)\n\nInputs\n\nimg::EHTImage : Image you want to rescale\nnpix : Number of pixels in x and y direction\nxlim : Tuple with the limits of the image in the RA in μas\nylim : Tuple with the limits of the image in DEC in μas\n\n\n\n\n\n","category":"method"},{"location":"api/function_index/#VIDA.blur-Tuple{EHTImage,Any}","page":"API","title":"VIDA.blur","text":"blur(img, fwhm)\n\n\nBlurs the img with a gaussian kernel with fwhm in μas. If fwhm is a scalar then the kernel is assumed to be symmetric, otherwise you the first entry is the fwhm in the EW direction and second the NS direction.\n\nReturns the blurred image.\n\n\n\n\n\n","category":"method"},{"location":"api/function_index/#Base.size-Tuple{EHTImage}","page":"API","title":"Base.size","text":"size(img::EHTImage)\n\nFinds the size of the image, i.e. the number of pixels in the y and x directions\n\nReturns: (npixy, npixx)\n\n\n\n\n\n","category":"method"},{"location":"api/function_index/#VIDA.clipimage","page":"API","title":"VIDA.clipimage","text":"clipimage(clip, im)\nclipimage(clip, im, mode)\n\n\nClips the image im according to the value clip. There are two modes for image clipping:     - :relative which zeros the pixels whose intensity are below clip relative to the max.     - :absolute which zeros the pixels whose intensity is below clip in Jy/pixel\n\n\n\n\n\n","category":"function"},{"location":"api/function_index/#VIDA.field_of_view","page":"API","title":"VIDA.field_of_view","text":"field_of_view(img)\n\n\nFinds the field of view of an EHTImage. Return a w element tuple with the field of view in the x and y direction\n\n\n\n\n\n","category":"function"},{"location":"api/function_index/#Movies","page":"API","title":"Movies","text":"","category":"section"},{"location":"api/function_index/","page":"API","title":"API","text":"VIDA also has a movie interface using hdf5. Note that movies are more than just a list of images. We also use an interpolation between frames.","category":"page"},{"location":"api/function_index/","page":"API","title":"API","text":"AbstractMovie\nEHTMovie\nload_hdf5\nsave_hdf5\njoin_frames\nget_times\nget_frames\nget_image\nflux(::EHTMovie, ::Any)\nblur(::EHTMovie, ::Any)\nrescale(::EHTMovie,::Any,::Any,::Any)","category":"page"},{"location":"api/function_index/#VIDA.AbstractMovie","page":"API","title":"VIDA.AbstractMovie","text":"abstract type AbstractMovie\n\nCreates an abstract movie class\n\n\n\n\n\n","category":"type"},{"location":"api/function_index/#VIDA.EHTMovie","page":"API","title":"VIDA.EHTMovie","text":"struct EHTMovie{F, T<:(Interpolations.AbstractExtrapolation{F,N,ITPT,IT} where IT where ITPT where N)} <: VIDA.AbstractMovie\n\nDetails\n\nThe type is to hold a EHT movie. The dimension of the movie array is assumed to be in the form DEC,RA,Time.\n\nnx is the number of pixels in the x or RA direction ny is the number of pixels in the y or DEC direction psize_x, psize_y are the pixel sizes in the x and y direction source is the source we are looking at e.g. M87 ra,dec are the sources RA and DEC in J2000 coordinates using degrees wavelength is the wavelength of the image. mjd is the Modified Julian Date of the observation. frames is the interpolation object that hold the movie frames\n\n\n\n\n\n","category":"type"},{"location":"api/function_index/#VIDA.load_hdf5","page":"API","title":"VIDA.load_hdf5","text":"load_hdf5(filename; style)\n\n\nLoads an hdf5 file where filename should be a HDF5 file.\n\nDetails\n\nThis reads in a hdf5 file and outputs and EHTMovie object.\n\nNotes\n\nCurrently this only works with movies created by ehtim. SMILI uses a different format, as does Illinois, and every other group...\n\n\n\n\n\n","category":"function"},{"location":"api/function_index/#VIDA.save_hdf5","page":"API","title":"VIDA.save_hdf5","text":"save_hdf5(filename, mov; style)\n\n\nSaves and hdf5 file where filename is the write out location. Currently style only works with ehtim, namely we save HDF5 files that only work with ehtim.\n\n\n\n\n\n","category":"function"},{"location":"api/function_index/#VIDA.join_frames","page":"API","title":"VIDA.join_frames","text":"join_frames(times, images)\n\n\nJoins an array of EHTImages at specified times to form an EHTMovie object.\n\nInputs\n\ntimes: An array of times that the image was created at\nimages: An array of EHTImage objects\n\nOutputs\n\nEHTMovie object\n\n\n\n\n\n","category":"function"},{"location":"api/function_index/#VIDA.get_times","page":"API","title":"VIDA.get_times","text":"get_times(mov)\n\n\nReturns the times that the movie object mov was created at. This does not have to be uniform in time.\n\n\n\n\n\n","category":"function"},{"location":"api/function_index/#VIDA.get_frames","page":"API","title":"VIDA.get_frames","text":"get_frames(mov)\n\n\nGets all the frames of the movie object mov. This returns a array of EHTImage objects.\n\n\n\n\n\n","category":"function"},{"location":"api/function_index/#VIDA.get_image","page":"API","title":"VIDA.get_image","text":"get_image(mov, t)\n\n\nGets the frame of the movie object mov at the time t. This returns an EHTImage object at the requested time. The returned object is found by linear interpolation.\n\n\n\n\n\n","category":"function"},{"location":"api/function_index/#VIDA.flux-Tuple{EHTMovie,Any}","page":"API","title":"VIDA.flux","text":"flux(mov, t)\n\n\nReturns the flux of the mov at the times time in fractional hours\n\n\n\n\n\n","category":"method"},{"location":"api/function_index/#VIDA.blur-Tuple{EHTMovie,Any}","page":"API","title":"VIDA.blur","text":"blur(mov, fwhm)\n\n\nBlurs the mov with a gaussian kernel with fwhm in μas. If fwhm is a scalar then the kernel is assumed to be symmetric, otherwise you the first entry is the fwhm in the EW direction and second the NS direction.\n\nReturns the blurred movie.\n\n\n\n\n\n","category":"method"},{"location":"api/function_index/#VIDA.rescale-Tuple{EHTMovie,Any,Any,Any}","page":"API","title":"VIDA.rescale","text":"rescale(mov::EHTMovie, npix, xlim, ylim)\n\nInputs\n\nmov::EHTMovie : Movie you want to rescale\nnpix : Number of pixels in x and y direction\nxlim : Tuple with the limits of the image in the RA\nylim : Tuple with the limits of the image in DEC\n\n\n\n\n\n","category":"method"},{"location":"api/function_index/#Divergences","page":"API","title":"Divergences","text":"","category":"section"},{"location":"api/function_index/","page":"API","title":"API","text":"AbstractDivergence\nBhattacharyya\nKullbackLeibler","category":"page"},{"location":"api/function_index/#VIDA.AbstractDivergence","page":"API","title":"VIDA.AbstractDivergence","text":"abstract type AbstractDivergence\n\nAn abstract class for a divergence of a function. This expects that a subtype has a field with an EHTImage object and a flux type. The struct is then assumed to be a functor and have a function that computes the divergence of the image and a filter.\n\nFor example\n\n    struct MyDiv{T,S} <: AbstractDivergence\n        img::EHTImage{T}\n        flux::S\n    end\n    function (bh::MyDiv)(θ::AbstractFilter)\n        ...\n    end\n\n\n\n\n\n","category":"type"},{"location":"api/function_index/#VIDA.Bhattacharyya","page":"API","title":"VIDA.Bhattacharyya","text":"struct Bhattacharyya{T, S} <: VIDA.AbstractDivergence\n\nType for the Bhattacharyya divergence. It constructed from an EHTImage i.e. data. Additionally to evaluate the divergence we use a functor approach where if θ is your\n\nDetails\n\nThis computes the Bhattacharyya divergence which is related to Hellinger distance between two distributions. In fact, they are both minimized at the same point. The Bhattacharyya divergence is defined as\n\nBh(f_thetahatI) = -logint sqrtf_theta(xy)hatI(xy)dxdy\n\nwhere hatI is defined as the image normalized to unit flux.\n\n\n\n\n\n","category":"type"},{"location":"api/function_index/#VIDA.KullbackLeibler","page":"API","title":"VIDA.KullbackLeibler","text":"struct KullbackLeibler{T, S} <: VIDA.AbstractDivergence\n\nType for the KL divergence. It constructed from an EHTImage i.e. data. Additionally to evaluate the divergence we use a functor approach where if θ is your\n\nDetails\n\nThis computes the KL divergence which is related to Hellinger distance between two distributions. In fact, they are both minimized at the same point. The Bhattacharyya divergence is defined as\n\nKL(f_thetahatI) = -logint f_theta(xy)log\n        left(fracf_theta(xy)hatI(xy)right)dxdy\n\nwhere hatI is defined as the image normalized to unit flux.\n\nThis struct is also a functor.\n\n\n\n\n\n","category":"type"},{"location":"api/function_index/#Extractor","page":"API","title":"Extractor","text":"","category":"section"},{"location":"api/function_index/","page":"API","title":"API","text":"This defines the interface to the optimizers that can find the optimal filter for a given image.","category":"page"},{"location":"api/function_index/","page":"API","title":"API","text":"Optimizer\nBBO\nCMAES\nOpt\nExtractProblem\nextractor\nthreaded_extractor","category":"page"},{"location":"api/function_index/#VIDA.Optimizer","page":"API","title":"VIDA.Optimizer","text":"abstract type Optimizer\n\nAbstract optimizer class that defines the optimizer to use. This is the interface I'll need to define all the different optimizer classes below.\n\n\n\n\n\n","category":"type"},{"location":"api/function_index/#VIDA.BBO","page":"API","title":"VIDA.BBO","text":"struct BBO <: VIDA.Optimizer\n\nDefines the interface for the BlackBoxOptim interface. This requires that the user to have imported the BlackBoxOptim package.\n\nFields\n\npopsize: The population size DEFAULT 64\nmaxevals: The maximum number of times to evaluate the divergence before terminiation.\ntracemode: The output option. Default is silent, i.e. no output.\n\nOther options are :compact and :verbose\n\nNotes\n\nThis uses the default BlackBoxOptim optimizer i.e. adaptivederand1bin_radiuslimited. Currently other options aren't implemented since I found that this version tended to work the best.\n\n\n\n\n\n","category":"type"},{"location":"api/function_index/#VIDA.CMAES","page":"API","title":"VIDA.CMAES","text":"struct CMAES <: VIDA.Optimizer\n\nDefines the interface for the LBFGS-B interface from the Optim.jl package. This requires that the user to have imported the CMAEvolutionStrategy package.\n\nTypically I have found that this works very well. This the usual first optimizer to try.\n\nFields\n\npopsize\nPopulationSize  Default: 64\ncov_scale\nInitial covariance scale  Default: 1.0\nftarget\ntarget divergence values. nothing means there is no target  Default: nothing\nxtol\nxtol Default: nothing\nftol\nftol Default: 1.0e-11\nmaxevals\nmaximum number of divergence evals, nothing means run until termination Default: nothing\nverbosity\nverbosity of output Default: 1\n\n\n\n\n\n","category":"type"},{"location":"api/function_index/#VIDA.Opt","page":"API","title":"VIDA.Opt","text":"struct Opt{O<:Optim.AbstractConstrainedOptimizer} <: VIDA.Optimizer\n\nDefines the interface for the LBFGS-B interface from the Optim.jl package. This requires that the user to have imported the Optim package.\n\nFields\n\nopt\noptions\nDefault: Optim.Options()\n\n\n\n\n\n","category":"type"},{"location":"api/function_index/#VIDA.ExtractProblem","page":"API","title":"VIDA.ExtractProblem","text":"ExtractProblem{T<:AbstractDivergence, S<:AbstractFilter}\n\nDefines a feature extraction problem to minimize, with an abstract filte and an abstract divergence. This is needed to interface with the extractor minimizer, which will minimize the divergence to find the optimal filter.\n\nFields\n\ndiv\nDivergence function to minimize\nθinit\nInitial location of the optimizer\nθlower\nLower bound of the search region\nθupper\nUpper bound of the search region\n\n\n\n\n\n","category":"type"},{"location":"api/function_index/#VIDA.extractor","page":"API","title":"VIDA.extractor","text":"extractor(prob::ExtractProblem, optimizer::Optimizer)\n\nThis extracts the optimal filter defined by the prob problem. This will minimize the divergence in prob and return the optimal filter and minimum divergence in a tuple.\n\noptimizer is one of VIDA's optimizer types. Typically I would recommend the BBO() optimizer\n\nExamples\n\n    θopt, divmin = extractor(prob, BBO())\n\n\n\n\n\n","category":"function"},{"location":"api/function_index/#VIDA.threaded_extractor","page":"API","title":"VIDA.threaded_extractor","text":"threaded_extractor(nstart::Int, prob::ExtractProblem, optimizer::Optimizer)\n\nA threaded multi-start version of the extractor method. This will run nstart instances of extractor, where the initial location of chosen uniformly within the bounds defined in prob.\n\nOutputs\n\nThis outputs the best filter and minimum divergence of all the extractors run.\n\n\n\n\n\n","category":"function"},{"location":"api/function_index/#Utilities","page":"API","title":"Utilities","text":"","category":"section"},{"location":"api/function_index/","page":"API","title":"API","text":"make_image","category":"page"},{"location":"api/function_index/#VIDA.make_image","page":"API","title":"VIDA.make_image","text":"make_image(θ, npix, xlim, ylim; intensity, source, wavelength, ra, dec, mjd)\n\n\nCreates an EHTImage type from the filter type. The number of pixels in the image are given by npix and the field of view in μas in the x and y direction are given by xlim and ylim. The rest of the options are the default image characteristics\n\n\n\n\n\nmake_image(θ, npix, xlim, ylim, source_img; intensity)\n\n\nCreates an EHTImage type from the filter type. The number of pixels in the image are given by npix and the field of view in μas in the x and y direction are given by xlim and ylim. To define the source we use an source_img.\n\n\n\n\n\n","category":"function"},{"location":"api/function_index/#Visualizations","page":"API","title":"Visualizations","text":"","category":"section"},{"location":"api/function_index/","page":"API","title":"API","text":"triptic","category":"page"},{"location":"api/function_index/#VIDA.triptic","page":"API","title":"VIDA.triptic","text":"triptic(img::EHTImage, filter)\n\nPlots a triptic where the left panel is the img middle the filter and the right a two cross-sections of the image and filter\n\n\n\n\n\n","category":"function"},{"location":"interface/#Interface","page":"Interface","title":"Interface","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"The interface is based off of using probability divergences to extract features from images. The main functions a user needs to be aware of are:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"#load the image\nimage = load_fits(file::String)\n#create the divergence we want (Bhattacharyya divergence)\nbh = Bhattacharyya(image)\n#Create the filter we want to use to extract for example an slashed elliptical Gaussian\nfilter = GeneralGaussianRing(p::Array) <: AbstractFilter\n#To extract the features we define the ExtractProblem and run extractor\nprob = ExtractProblem(divergence, filter::T, filter_lower::T, filter_upper::T) where {T<:AbstractFilter}\nopt_filter, divmin = extractor(prob, opt::Optimizer)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Let's dive into what each piece means","category":"page"},{"location":"interface/#Image-type:-EHTImage","page":"Interface","title":"Image type: EHTImage","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"This is the image you want to fit. Currently we only have support for fits images that are similar to the fits image objects created by ehtim. These images are loaded with the function","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"  #load fits image\n  image = load_fits(\"fitsname.fits\")","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"There are an additional number of tools available for image processing, such as clipping flux and rescaling the image. For a list of such functions please refer to the API page.","category":"page"},{"location":"interface/#Filter-type-AbstractFilter","page":"Interface","title":"Filter type AbstractFilter","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"This is the filter that will be used to extract an image feature. Basically it will find the filter that is the closest to. Currently there are 4 types of filters implemented, but each are a subset of the other:","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"    GaussianRing(p) #Gaussian circular ring\n    SlashedGaussianRing(p) #Gaussian circular ring with flux asymmetry\n    EllipticalGaussianRing(p) #Gaussian elliptical ring\n    TIDAGaussianRing(p)  #Gaussian elliptical ring with flux asymmetry where the orientations relative to each other are fixed\n    GeneralGaussianRing(p) #Gaussian elliptical slashed ring where orientation of the slash and asymmetry are independent.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"For the parameters that it takes please use the julia ? mode.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"The plotting is done through the recipes macros in Plots.jl. So it should just work! In addition to the plot function there is a new recipe called triptic(img,θ) that will produce a comparison between the filter and the true image. This can be useful when comparing the best filter to the image.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Additionally any other function that dispatches on the filter type should just work! One thing to note is that the weight between the two filters is relative. Namely, total intensity will always be normalized, so the above code says that θ2 has 5 times the relative flux compared to the first.","category":"page"},{"location":"interface/#Divergence-AbstractDivergence","page":"Interface","title":"Divergence AbstractDivergence","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"In order to extract a feature you need to create a probability divergence function. Currently the divergences are defined using a AbstractDivergence type. Currently we have two divergences implemented Bhattacharyya divergence (Bh) and the Kullback-Leiber divergence (KL). In order to construct the divergence we first need to specify the image that we are trying to fit.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"bh = Bhattacharyya(image) #make the Bh divergence\nkl = KullbackLeibler(image) #makes the KL divergence","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"which creates a functor that depends on the image. The functor itself take a filter, e.g.,","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"bh(θ::AbstractFilter)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"and bh will use multiple dispatch to figure out which filter function to use.","category":"page"},{"location":"interface/#Extract-features-extractor-and-ExtractProblem-and-Optimizer","page":"Interface","title":"Extract features extractor and ExtractProblem and Optimizer","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"We then use the extractor function to extract the image feature. To call extractor you need to define a ExtractProblem type with the call","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"prob = ExtractProblem(divergece, filter, filter_lower, filter_upper)","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"where divergence is your probability divergence, filter is the filter function and filter_lower and filter_upper are the filters that represent the lower and upper bounds you want to search over. Once you have your problem defined you can find the optimal filter and extract image features using the extractor function","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"opt_filter, divmin = extractor(prob, BBO())","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Here BBO() used the BlackBoxOptim.jl package to optimize. Currently, I have 3 packages that are incorporated with VIDA","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"BBO(), BlackBoxOptim.jl which uses genetic and evolutionary algorithms to find global maximum.\nCMAES(), CMAESEvolutionStrategy.jl which uses the CMA-ES genetic algorithm to find the global maximum.\nOpt(),  Optim.jl, which allows you to use and box-constrained optimizer from the Optim.jl package, e.g. SAMIN().","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"In the future I may add interfaces. In terms of which optimizer to select I would suggest to use BBO() as your default, maybe with the maxevals increased from the default 25_000. For other options you can see the documentation and help.","category":"page"},{"location":"interface/","page":"Interface","title":"Interface","text":"Note there is a threaded version of the extractor threaded_extractor(nstart, prob, BBO()) that run nstart runs of extractor, with different initial conditions randomly sampled in the box-constraints.","category":"page"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/#A-minimal-example-of-extracting-ring-features","page":"Getting Started","title":"A minimal example of extracting ring features","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"We have provided a minimal example of how to run the filter in examples using command line arguments. A simpler example is","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"  using VIDA\n  #load the image and plot it\n  image = load_fits(\"examples/data/elliptical_gaussian_rot-0.00.fits\")\n  plot(image)\n\n  #Create the filter to use\n  filter = GaussianRing(20.0, #20 μas Gaussian ring\n                            5.0,  #std dev is 5.0 μas\n                            0.0,  #RA (x) location of ring center in μas\n                            0.0   #DEC (y) locatin of ring center in μas\n                           )\n  #Plot the filter\n  plot(filter)\n\n  #make the measure you can choose from :KL or :Bh currently.\n  bh = Bhattacharyya(image)\n  \n  #To call the function bh\n  bh(filter)\n\n  #Now lets define our extraction problem, i.e. the filter, bounds, and divergence\n  lower = GaussianRing(0.1, 0.01, -60.0, -60.0)\n  upper = GaussianRing(40.0, 20.0, 60.0, 60.0)\n  prob = ExtractProblem(bh, filter, lower, upper)\n  #Now we run the extractor with the BlackBoxOptim optimizer\n  opt_filter, divmin = extractor(prob, BBO())\n\n  #Now lets run 8 extractors using threads and the CMAES optimizer\n  opt_filter, divmin = threaded_extractor(prob, CMAES(ftol=1e-20, cov_scale=10))\n  \n  #plot the results\n  triptic(image, opt_filter)","category":"page"},{"location":"getting_started/#Idea-behind-VIDA","page":"Getting Started","title":"Idea behind VIDA","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"VIDA is based on the idea of interpreting the image as a probability distribution. Namely since any image is integrable, the space of images is in one-to-one correspondence with a probability distribution.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Therefore, our idea is very close to variational inference, hence the name (the) Variational Image Domain Analysis. Namely, where we view the image as a distribution and we aim to find a approximation of the distribution given some parametric family f_theta(xy), which for our purposes we will typically call a filter.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The choice of filter, depends on the problem of interest, namely what features we are interested in. Typically for the Event Horizon Telescope (EHT) where the images tend to be rings, we are interested in","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Radius r₀\nWidth or half width σ\nStructural asymmetry τ\nFlux asymmetry s\nPosition angle ξ","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"VIDA then defines a series of filters parameterize these features.","category":"page"},{"location":"getting_started/#Filters","page":"Getting Started","title":"Filters","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Currently we have 6 filters defined, although they all belong to the same family. For an example on how to see the process for defining your own filter please see the Adding a Custom Filter.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The filters implemented are:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"CosineRing{N,M} which defines a ring with a cosine expansion in azimuthal thickness (order N) and brightness (order M).\nGaussianRing which is a symmetric and circular Gaussian ring.\nSlashedGaussianRing which is a circular Gaussian ring with a flux gradient across its emission.\nEllipticalGaussianRing symmetric Gaussian elliptical ring, where the emission is constant across the ring, unlike with the SlashedGaussianRing.\nGeneralGaussianRing A combination of the two above where the ring is allowed to be elliptical and have a intensity gradient.\nTIDAGaussianRing The GeneralGaussianRing, but where the asymmetry and flux orienation are fixed relative to one another.\nAsymGaussian A asymmetric Gaussian blob. This can be useful if you image has a strong non-ring component in it.\nConstant Adds a constant flux floor to the image. This is very helpful for image reconstructions that tend to add small scale flux everywhere in the image.","category":"page"},{"location":"getting_started/#Divergences","page":"Getting Started","title":"Divergences","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"In order to extract features we first need a cost function that penalized our parameterized distributions f_theta(xy). Since we are considering the image as a probability distribution, one cost function would be the distance or divergence between two distributions. A probability divergence is just a functional that takes in two probability distributions p,q and is minimized iff pequiv q. ","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Divergences are defined by the abstract type AbstractDivergence. Implementations of the this type are also expected to implement a functor that evaluates the divergence on some filter. For an example see the implementation of the divergences in ","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Currently we have two divergences implemented in VIDA","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Bhattacharyya divergence (Bh)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":" Bh(f_thetaI) = int sqrtf_theta(xy)I(xy) dxdy","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"KL divergence","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":" KL(f_thetaI) = int f_theta(xy)logleft(fracf_theta(xy)I(xy)right)dxdy ","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Both divergences give very similar answers, although we found the Bh to be easier to maximize.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"EditURL = \"https://github.com/ptiede/VIDA.jl/blob/master/example/introduction.jl\"","category":"page"},{"location":"generated/introduction/#Introduction-to-VIDA","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"","category":"section"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"Using VIDA is based on constructing three items:","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"Data, i.e. an image that you want to extract features from.\nCost function, i.e. pick if you want to use the KL or BH divergence\nFilter, i.e. construct the family of distributions or filters that you will use to approximate the image.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"Then all you need to do is minimize the divergence and you will have extracted you image features.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"Now lets runs through how that works","category":"page"},{"location":"generated/introduction/#Getting-started","page":"Introduction to VIDA","title":"Getting started","text":"","category":"section"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"To load VIDA we follow the typical Julia flow. Note that to include plotting functionality you need to include Plots as well","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"using Plots\nusing VIDA\nusing InteractiveUtils","category":"page"},{"location":"generated/introduction/#Step-1-Read-in-Data","page":"Introduction to VIDA","title":"Step 1 Read in Data","text":"","category":"section"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"VIDA currently only works with fits images. THe fits header is based off of what eht-imaging outputs. So as long as you stick to that standard you should be fine.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"To read in an image we just use the load_fits function which should work with any fits image from ehtim and clean","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"img = load_fits(joinpath(dirname(pathof(VIDA)),\"../example/data/example_image.fits\"));\nnothing #hide","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"To see what this img is lets print the type","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"println(typeof(img))","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"To plot the image we can just call plot. This uses recipes and the Plots.jl framework","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"plot(img)","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"So from the output we see that img is a EHTImage type. The information in the curly brackets defines the parametric type information. What this means is that the image that is constrained in the EHTImage type is a Matrix whose elements are Float64's.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"Julia isn't a traditional class OOP language. Namely, methods/functions are first class and aren't members of a class. Instead how a function behaves is dependent on the type of argument inputs. This is known as something called multimethods or multiple dispatch where at run-time the type of functions called is determined by the arguments.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"In some sense OOP is just a multiple dispatch type language where the our type of dispatch only depends on the class, i.e. the self argument in Python classes.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"Now because of the lack of classes sometimes it can be difficult to figure out which functions will act of our datatypes, e.g. the EHTImage type. Fortunately, Julia has some convenience functions that let you see which functions/methods can act of the EHTImage type","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"To see what functions can act on an EHTImage object just call","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"methodswith(EHTImage)","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"From this list we see there are several methods that can act on EHTImage types. To see what a certain function does you can type ?inertia in the terminal to see the help for the inertia method.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"# Creating a divergence","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"In order to find the optimal filter you need to first decide on your objective or cost function. In VIDA we use probaility divergences to measure differences between the filter and image. A divergence is defined as an abstract type AbstractDivergence. In VIDA a divergence is a functor. A functor is a type that has an anonymous function attached to it. That means it is both a type and a function. For instance we create a divergence by","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":" bh = Bhattacharyya(img);\n kl = KullbackLeibler(img);\nnothing #hide","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"Now to evaluate the divergence we need to pass it a filter. This can be any filter your choose. The great thing about julia is that bh will use multiple dispatch to figure out which filter is being passed to the divergence.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"For instance lets create a few different filters","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"gr = GaussianRing(r0=20.0, σ=5.0, x0=0.0, y0=0.0)\nggr = GeneralGaussianRing(r0=20.0,\n                          σ = 5.0,\n                          τ = 0.2,\n                          ξτ = 0.78,\n                          s = 0.5,\n                          ξs = 0.78,\n                          x0=0.0,\n                          y0=0.0\n                        )","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"We can also plot both filters","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"a = plot(gr, title=\"GaussianRing\")\nb = plot(ggr, title=\"GeneralGaussianRing\")\nplot(a, b, layout=(1,2), size=(600,300))","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"VIDA has a number of filters defined. These are all subtypes of the AbstractFilter type. To see which filters are implemented you can use the subtype method:","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"subtypes(VIDA.AbstractFilter)","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"Note that the AddFilter and MulFilter are internal filters that allow the user to easily combine two filters, for example:","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"add = gr + 1.0*ggr","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"To evaluate the divergence between our filter and image we then just evaluate the divergence on the filter","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"@show bh(gr);\n@show bh(ggr);\n@show bh(add);\nnothing #hide","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"Now neither filter is really a great approximation to the true image. For instance visually they look quite different, which can be checked with the triptic function","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"a = triptic(img, gr)\nb = triptic(img, ggr)\nc = triptic(img, add)\nplot(a,b,c, layout=(3,1), size=(800,800))","category":"page"},{"location":"generated/introduction/#Extracting-the-Optimal-Filter","page":"Introduction to VIDA","title":"Extracting the Optimal Filter","text":"","category":"section"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"To extract the optimal filter the first thing you need to do is define your ExtractProblem. This requires your divergence, initial filter, and bounds.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"lower = GaussianRing(r0=0.1, σ=0.01, x0=-60.0, y0=-60.0);\nupper = GaussianRing(r0=60.0, σ=20.0, x0=60.0, y0=60.0);\ninitial = GaussianRing(r0=20.0, σ=5.0, x0=0.0, y0=0.0);\n\nprob = ExtractProblem(bh, initial, lower, upper);\nnothing #hide","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"Now to run the optimizers you just need to select which optimizer to use. Currently VIDA has three families of optimizers installed. Each one is a subtype of the VIDA.Optimizer abstract type","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"subtypes(VIDA.Optimizer)","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"Of the three implemented optimizers my suggestion would be to try the BBO one first. This uses the BlackBoxOptim.jl package. BBO has a number of options that can be changed. To see them please use the julia ? mode, or see the documentation.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"However, for this tutorial I am going to use the CMAES optimizer since it is faster albeit less robust to local minima","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"To optimize all you need to do is run the extractor function.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"optfilt, divmin = extractor(prob, CMAES())\ntriptic(img, optfilt)","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"Well that seemed to do a terrible job. The reason is that a lot of these images tend to have some low level flux throughout the image. To account for this the filter tends to get very big to absorb some of this flux. To combat this you can add a constant background filter to the problem.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"lower = GaussianRing(r0=0.1, σ=0.01, x0=-60.0, y0=-60.0) + 1e-10*Constant();\nupper = GaussianRing(r0=60.0, σ=20.0, x0=60.0, y0=60.0) + 1.0*Constant();\ninitial = GaussianRing(r0=20.0, σ=5.0, x0=0.0, y0=0.0) + 0.1*Constant();\n\nprob = ExtractProblem(bh, initial, lower, upper);\noptfilt, divmin = extractor(prob, CMAES())\ntriptic(img, optfilt)","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"We can also run multple instances of the extractor, and use Julia's Threads interface","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"optfilt, divmin = threaded_extractor(4, prob, CMAES())","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"This will run 4 instances of the extractor function using the available threads in the Julia session.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"That's much better! Now if you wanted to capture the asymmetry in the ring you can use other filters, for example the CosineRing filter. Note that this filter tends to be a little harder to fit.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"lower = CosineRing{1,4}(r0=0.1,\n                        σ=[0.1, -1.0], ξσ = [-π],\n                        τ = 0.01, ξτ = -π,\n                        s = [0.01, -1.0, -1.0, -1.0],\n                        ξs = [-π,-π,-π,-π],\n                        x0=-60.0, y0=-60.0\n                       ) + 1e-10*Constant();\nupper = CosineRing{1,4}(r0=40.0,\n                        σ=[20.0, 1.0], ξσ = [π],\n                        τ = 0.999, ξτ = π,\n                        s = [0.999, 1.0, 1.0, 1.0],\n                        ξs = [π,π,π,π],\n                        x0=60.0, y0=60.0\n                       ) + 1.0*Constant();\ninitial = CosineRing{1,4}(r0=20.0,\n                        σ=[5.0, 0.1], ξσ = [0.0],\n                        τ = 0.1, ξτ = 0.0,\n                        s = [0.1, 0.0, 0.0, 0.0],\n                        ξs = [0.0,0.0,0.0,0.0],\n                        x0=0.0, y0=0.0\n                       ) + 1e-2*Constant();\n\nprob = ExtractProblem(bh, initial, lower, upper);\noptfilt, divmin = extractor(prob, CMAES(verbosity=0));\ntriptic(img, optfilt)","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"Now looks pretty great! To see how to add a custom filter see the Adding a Custom Filter page.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/custom_filter/","page":"Adding a Custom Filter","title":"Adding a Custom Filter","text":"EditURL = \"https://github.com/ptiede/VIDA.jl/blob/master/example/custom_filter.jl\"","category":"page"},{"location":"generated/custom_filter/#Adding-a-Custom-Filter","page":"Adding a Custom Filter","title":"Adding a Custom Filter","text":"","category":"section"},{"location":"generated/custom_filter/","page":"Adding a Custom Filter","title":"Adding a Custom Filter","text":"If you want to add your own filter you just need to define a new:","category":"page"},{"location":"generated/custom_filter/","page":"Adding a Custom Filter","title":"Adding a Custom Filter","text":"filter type\nsize method\nimagefilter method for that type of filter.","category":"page"},{"location":"generated/custom_filter/","page":"Adding a Custom Filter","title":"Adding a Custom Filter","text":"For example to add a symmetric gaussian filter we can use:","category":"page"},{"location":"generated/custom_filter/","page":"Adding a Custom Filter","title":"Adding a Custom Filter","text":"using VIDA\n\nBase.@kwdef struct SymGaussian <: VIDA.AbstractFilter\n   σ::Float64 #standard deviation of the Gaussian\n   x0::Float64 #x location of mean\n   y0::Float64 #y location of mean\nend\n\nSymGaussian(p) = SymGaussian(p[1],p[2],p[3])\n\nBase.size(::Type{SymGaussian}) = 3\n\nfunction (θ::SymGaussian)(x,y)\n  z2 = ((x-θ.x0)^2 + (y-θ.y0)^2)/(2.0*θ.σ^2)\n  return 1.0/(2.0*π*θ.σ^2)*exp(-z2)\nend","category":"page"},{"location":"generated/custom_filter/","page":"Adding a Custom Filter","title":"Adding a Custom Filter","text":"Then you can simply call the same optimizing functions and plotting functions. For example lets create a fake image and fit it","category":"page"},{"location":"generated/custom_filter/","page":"Adding a Custom Filter","title":"Adding a Custom Filter","text":"filter = SymGaussian(σ=20.0, x0=0.0, y0=0.0)","category":"page"},{"location":"generated/custom_filter/","page":"Adding a Custom Filter","title":"Adding a Custom Filter","text":"Now I will use a utility function to convert a filter to an EHTImage","category":"page"},{"location":"generated/custom_filter/","page":"Adding a Custom Filter","title":"Adding a Custom Filter","text":"img = VIDA.make_image(filter, 64, (-60.0,60.0), (-60.0,60.0));\nnothing #hide","category":"page"},{"location":"generated/custom_filter/","page":"Adding a Custom Filter","title":"Adding a Custom Filter","text":"Now lets see if we can get the correct parameters","category":"page"},{"location":"generated/custom_filter/","page":"Adding a Custom Filter","title":"Adding a Custom Filter","text":"bh = Bhattacharyya(img);\nnothing #hide","category":"page"},{"location":"generated/custom_filter/","page":"Adding a Custom Filter","title":"Adding a Custom Filter","text":"Define the starting point for the optimization and the bounds","category":"page"},{"location":"generated/custom_filter/","page":"Adding a Custom Filter","title":"Adding a Custom Filter","text":"start = SymGaussian(rand(3))\nupper = SymGaussian(σ=40.0, x0=60.0, y0=60.0)\nlower = SymGaussian(σ=0.001, x0=-60.0, y0=-60.0)\n\nprob = ExtractProblem(bh, start, lower, upper)\n\nθopt, divmin = extractor(prob, CMAES())\n\n@show θopt","category":"page"},{"location":"generated/custom_filter/","page":"Adding a Custom Filter","title":"Adding a Custom Filter","text":"Let's also plot the results","category":"page"},{"location":"generated/custom_filter/","page":"Adding a Custom Filter","title":"Adding a Custom Filter","text":"triptic(img, filter)","category":"page"},{"location":"generated/custom_filter/","page":"Adding a Custom Filter","title":"Adding a Custom Filter","text":"","category":"page"},{"location":"generated/custom_filter/","page":"Adding a Custom Filter","title":"Adding a Custom Filter","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#VIDA.jl","page":"Home","title":"VIDA.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Variational image domain analysis for the EHT. This package is for extracting features, such as ring from image reconstruction of EHT data. Currently these images must be in fits format although other types  my be included in the future.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"VIDA is a registered Julia package to install","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg; Pkg.add(\"VIDA\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"or go to the repl and simply type ]add VIDA. Note that we require a Julia version >= 1.4.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some additional dependencies that enable full functionality can be added with","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pkg.add.([\"Plots\",\"ArgParse\"])","category":"page"},{"location":"","page":"Home","title":"Home","text":"Plots.jl is required to use some of the plotting recipes defined in the package and ArgParse is used for some of the scripts in the example folder.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To extract features we use probability divergences to characterize differences between our image and some approximation. For the divergences implemented see the Getting Started page. The idea is then very  similar to variational inferences where we pick a parametric family of distributions which we call filters and then try to find the filter that minimizes the divergence. For the filters that are currently implemented  please see the page.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the API for the complete list of documented functions and types.","category":"page"},{"location":"#Outline","page":"Home","title":"Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n  \"index.md\",\n  \"getting_started.md\",\n  \"interface.md\",\n  \"generated/introduction.md\",\n  \"generated/custom_filter.md\",\n  \"api/function_index.md\"\n]","category":"page"}]
}
