var documenterSearchIndex = {"docs":
[{"location":"api/function_index/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/function_index/","page":"API","title":"API","text":"CurrentModule = VIDA","category":"page"},{"location":"api/function_index/#Contents","page":"API","title":"Contents","text":"","category":"section"},{"location":"api/function_index/","page":"API","title":"API","text":"Pages = [\"function_index.md\"]","category":"page"},{"location":"api/function_index/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/function_index/","page":"API","title":"API","text":"Pages = [\"function_index.md\"]","category":"page"},{"location":"api/function_index/","page":"API","title":"API","text":"Modules = [HypercubeTransform]","category":"page"},{"location":"api/function_index/#HypercubeTransform.ascube","page":"API","title":"HypercubeTransform.ascube","text":"`ascube(c)\n\nConstructs the object that contains the necessary information to move from the unit hypercube to the distribution space. This is the usual function to use when construct the transformation.\n\nThere are a few different behaviors depending on the type of the object.\n\nIf c::Distribution then this will store the distributions.\nIf c::Tuple{AbstractHypercubeTransform} then this will store the tuple\n\nExamples\n\nascube(Normal())\nascube(MultivariateNormal())\nascube((Normal(), Normal(2.0)))\nascube( (α = Uniform(), β = Normal()) )\n\n\n\n\n\n","category":"function"},{"location":"api/function_index/#HypercubeTransform.asflat","page":"API","title":"HypercubeTransform.asflat","text":"asflat(d::Distribution)\n\nComputes the transformation of the support of the distribution d such that the variables live on ℝⁿ where n is the dimension of the problem. This is essentially what Turing and Stan do when reparameterizing the model.\n\nThe returned object is a TransformVariables.AbstractTransform object and follows that interface. Please see the TransformVariable docs for more information.\n\n\n\n\n\n","category":"function"},{"location":"api/function_index/#HypercubeTransform.transform_tuple-Tuple{Tuple{Vararg{HypercubeTransform.AbstractHypercubeTransform, N}} where N, Any, Any}","page":"API","title":"HypercubeTransform.transform_tuple","text":"transform_tuple(tt, x, index)\n\n\nHelper function that steps through the transformation tuple\n\n\n\n\n\n","category":"method"},{"location":"api/function_index/#TransformVariables.inverse-Tuple{HypercubeTransform.AbstractHypercubeTransform, Any}","page":"API","title":"TransformVariables.inverse","text":"`inverse(c::AbstractHypercubeTransform, p)`\n\nTransforms from the parameter space p, to the unit hypercube defined by the transformation c.\n\nThe behavior of this function depends on the nature of c.\n\nIf c is a <: Distributions.Distributions and has a cdf method\n\nthis will just call the cdf function. If no cdf function is defined then a custom transformation depending on the type of c will be called. If no custom transformation exists then an error will be raised.\n\nIf c is a Tuple of transformations then inverse will iterate through the\n\ntuple using a similar method to the  TransformVariables.jl method.\n\n\n\n\n\n","category":"method"},{"location":"api/function_index/#TransformVariables.transform","page":"API","title":"TransformVariables.transform","text":"transform(c::AbstractHypercubeTransform, p)\n\nTransforms from the hypercube with coordinates p, to the parameter space defined by the transformation c.\n\nThe behavior of this function depends on the nature of c.\n\nIf c is a <: Distributions.Distributions and has a quantile method\n\nthis will just call the quantile function. If no quantile function is defined then a custom transformation depending on the type of c will be called. If no custom transformation exists then an error will be raised.\n\nIf c is a Tuple of transformations then transform will iterate through the\n\ntuple using a similar method to the  TransformVariables.jl method.\n\n\n\n\n\n","category":"function"},{"location":"api/function_index/#TransformVariables.transform-Tuple{HypercubeTransform.AbstractHypercubeTransform, Any}","page":"API","title":"TransformVariables.transform","text":"transform(c, x)\n\n\nComputes the transformation from the unit hypercube to the distribution space.\n\n\n\n\n\n","category":"method"},{"location":"interface/#Interfaces","page":"Interfaces","title":"Interfaces","text":"","category":"section"},{"location":"interface/#Templates","page":"Interfaces","title":"Templates","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"The template describe the image features we wish to extract.  As of 0.11 VIDA uses the ComradeBase.jl  and VLBISkyModels.jl interface. This means that any model that obeys that interface can be used within VIDA. Additionally VIDA defines a number of additional templates that are useful. For a complete list see the API page.","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"For specifically VIDA we have created a AbstractImageTemplate subtype of the ComradeBase.AbstractModel type and partially implemented some functions.  For instance, we assume that ComradeBase.imanalytic(::Type{<:AbstractImageTemplate}) = IsAnalytic(). As such if an end user wants to implement a new feature they just need to implement","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"ComradeBase.intensity_point(m::MyNewTemplate, p)\nComradeBase.radialextent(m::MyNewTemplate)","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"Note we do not implement the flux of the templates since they are often difficult to calculate.","category":"page"},{"location":"interface/#Ring-Templates","page":"Interfaces","title":"Ring Templates","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"As of VIDA 0.11 we also include a composite image template class called RingTemplate.","category":"page"},{"location":"interface/#Divergence-AbstractDivergence","page":"Interfaces","title":"Divergence AbstractDivergence","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"In order to extract a feature you need to create a probability divergence function. Currently the divergences are defined using a AbstractDivergence type. The general user-facing interface is","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"bh = Bhattacharyya(image) #make the Bh divergence\nkl = KullbackLeibler(image) #makes the KL divergence","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"to initialize the divergence. To evaluate the divergence on a template you use the divergence function","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"divergence(bh, θ::AbstractTemplate)\ndivergence(kl, θ::AbstractTemplate)","category":"page"},{"location":"interface/#Extract-features-vida-and-VIDAProblem","page":"Interfaces","title":"Extract features vida and VIDAProblem","text":"","category":"section"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"The main goal of VIDA is to extract image features. To do this we need to define the template and parameterization we want to use.  The first step is to create a template function that takes in a NamedTuple and returns an <:ComradeBase.AbstractModel. For example","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"temp(θ) = GaussianRing(θ.r0, θ.σ, θ.x0, θ.y0)","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"For our search we also need to provide the domain over which we want to search","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"lower = (r0 = 5.0, σ = 0.1, x0 = -60.0, y0 = 60.0)\nupper = (r0 = 30.0, σ = 5.0, x0 = -60.0, y0 = 60.0)","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"We can then form our VIDAProblem using the divergence defined above","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"prob = VIDAProblem(bh, temp, lower, upper)","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"Finally, to get the optimal parameters and template we can call the vida function","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"using OptimizationMetaheuristics\nxopt, opt_template, divmin = vida(prob, ECA())","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"warn: Warn\n","category":"page"},{"location":"interface/","page":"Interfaces","title":"Interfaces","text":"Older versions of VIDA also included a threaded version of vida. This no longer exists    and would give a race condition if someone tried to use it at this point due to a difference    in how divergence is calculated. If you want to run multiple copies of VIDA at once please    use Julia's Distributed functionality.","category":"page"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/#A-minimal-example-of-extracting-ring-features","page":"Getting Started","title":"A minimal example of extracting ring features","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The basic VIDA program mirrors the following structure","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using VIDA\n# load the image and plot it\nimage = load_fits(\"examples/data/elliptical_gaussian_rot-0.00.fits\")\nplot(image)\n# Build the divergence we want to fit\nbh = Bhattacharyya(image)\n# Create the template to use\ntemplate(θ) = SlashedGaussianRing(θ.r0, θ.σ, θ.s, θ.ξ, θ.x0, θ.y0) + θ.floor*Constant(μas2rad(100.0))\n\n#Define our bounds\nlower = (r0 = μas2rad(5.0), σ=μas2rad(1.0), \n         s=0.001, ξ=-1π, \n         x0=-μas2rad(60.0), y0 = -μas2rad(60.0), \n         floor=1e-6)\nupper = (r0 = μas2rad(30.0), σ=μas2rad(15.0), \n         s=0.999, ξ=1π, \n         x0=μas2rad(60.0), y0 = μas2rad(60.0), \n         floor=100.0)\n\nprob = VIDAProblem(bh, template, lower, upper)\n# Load your optimizer and run VIDA\nusing OptimizationBBO\nxopt, opt_temp, divmin = vida(prob, BBO_adaptive_de_rand_1_bin(); maxiters=50_000)\n\n#plot the results\ntriptic(image, opt_temp)","category":"page"},{"location":"getting_started/#Idea-behind-VIDA","page":"Getting Started","title":"Idea behind VIDA","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"VIDA is based on the idea of interpreting the image as a probability distribution. Namely since any image is integrable, the space of images is in one-to-one correspondence with a probability distribution.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Therefore, our idea is very close to variational inference, hence the name (the) Variational Image Domain Analysis. Namely, where we view the image as a distribution and we aim to find a approximation of the distribution given some parametric family f_theta(xy), which for our purposes we will typically call a template.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The choice of template, depends on the problem of interest, namely what features we are interested in. Typically for the Event Horizon Telescope (EHT) where the images tend to be rings, we are interested in","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Radius r₀\nWidth or half width σ\nStructural asymmetry τ\nBrightness asymmetry s\nPosition angle ξ","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"VIDA then defines a series of templates parameterize these features.","category":"page"},{"location":"getting_started/#Templates","page":"Getting Started","title":"Templates","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Currently we have 6 templates defined, although they all belong to the same family. For an example on how to see the process for defining your own template please see the Adding a Custom Template.","category":"page"},{"location":"getting_started/#Divergences","page":"Getting Started","title":"Divergences","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"In order to extract features we first need a cost function that penalized our parameterized distributions f_theta(xy). Since we are considering the image as a probability distribution, one cost function would be the distance or divergence between two distributions. A probability divergence is just a functional that takes in two probability distributions p,q and is minimized iff pequiv q.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Divergences are defined by the abstract type AbstractDivergence. Implementations of the this type are also expected to implement a functor that evaluates the divergence on some template.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The current recommended default template is the Bhattacharyya divergence although all the  template give similar answers. ","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"EditURL = \"../../../example/custom_template.jl\"","category":"page"},{"location":"generated/custom_template/#Adding-a-Custom-Template","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"","category":"section"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"If you want to add your own template you just need to define a new:","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"subtype of AbstractImageTemplate\nimplement the interface desribed in AbstractImageTemplate","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"For example to add a symmetric gaussian template we can use:","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"using VIDA\n\nstruct SlashedExponentialRing{T} <: VIDA.AbstractImageTemplate\n    αouter::T\n    αinner::T #standard deviation of the Gaussian\n    s::T\nend\n\nfunction VIDA.intensity_point(m::SlashedExponentialRing, p)\n    (;X, Y) = p\n    (;αinner, αouter, s) = m\n    r = hypot(X, Y)\n    ϕ = atan(X, -Y)\n\n    n = (1-s*cos(ϕ))\n\n    return n*r^αinner/(1 + r^(αouter + αinner+1))\nend","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"We can also add a convienence constructor","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"function SlashedExponentialRing(r0, αouter, αinner, s, ξs, x0, y0)\n    return modify(SlashedExponentialRing(αouter, αinner, s),\n            Stretch(r0, r0), Rotate(ξs), Shift(x0, y0))\nend","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"Then you can simply call the same optimizing functions and plotting functions. For example lets create a fake image and fit it","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"template = SlashedExponentialRing(μas2rad(20.0), 3.0, 4.0, 0.5, π/2, 0.0, 0.0)","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"VIDA uses ComradeBase and VLBISkyModels interface. Therefore, we can create an image using intensitymap","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"img = intensitymap(template, μas2rad(128.0), μas2rad(128.0), 64, 64)","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"We can also plot the image","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"using Plots\nplot(img)","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"Now lets see if we can get the correct parameters","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"bh = Bhattacharyya(img);\nnothing #hide","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"To fit we need to define a fitting function. For this our template function needs to accept a named tuple.","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"temp(θ) = SlashedExponentialRing(θ.r0, θ.αout, θ.αin, θ.s, θ.ξs, θ.x0, θ.y0)","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"Additionally we need to define the search region for our template extraction","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"upper = (r0=μas2rad(40.0), αout=10.0, αin = 10.0, s=0.999, ξs=1π, x0= μas2rad(60.0), y0= μas2rad(60.0))\nlower = (r0=μas2rad(5.0), αout=1.0, αin = 0.0, s=0.001, ξs=-1π, x0= -μas2rad(60.0), y0= -μas2rad(60.0))","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"We can now create our problem","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"prob = VIDAProblem(bh, temp, lower, upper)","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"The vida method can use any optimizer that works with Optimization.jl For this work we will use BlackBoxOptim.","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"using OptimizationBBO\nxopt, θopt, divmin = vida(prob, BBO_adaptive_de_rand_1_bin(); maxiters=50_000)\n\n@show θopt","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"Let's also plot the results","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"triptic(img, template)","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"Now with all of this said this template actually already exists in VIDA using the flexible RingTemplate.","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"rad = RadialDblPower(xopt.αin, xopt.αout)\nazi = AzimuthalCosine(xopt.s, xopt.ξs)\nt   = modify(RingTemplate(rad, azi), Stretch(xopt.r0), Shift(xopt.x0, xopt.y0))","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"triptic(img, t)","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"","category":"page"},{"location":"generated/custom_template/","page":"Adding a Custom Template","title":"Adding a Custom Template","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"EditURL = \"../../../example/introduction.jl\"","category":"page"},{"location":"generated/introduction/#Introduction-to-VIDA","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"","category":"section"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"Using VIDA is based on constructing three items:","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"Data, i.e. an image that you want to extract features from.\nCost function, i.e. pick if you want to use the KL or BH divergence\nTemplate, i.e. construct the family of distributions or templates that you will use to approximate the image.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"Then all you need to do is minimize the divergence and you will have extracted you image features.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"Now lets runs through how that works","category":"page"},{"location":"generated/introduction/#Getting-started","page":"Introduction to VIDA","title":"Getting started","text":"","category":"section"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"To load VIDA we follow the typical Julia flow. Note that to include plotting functionality you need to include Plots as well","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"using Plots\nusing VIDA\nusing InteractiveUtils","category":"page"},{"location":"generated/introduction/#Step-1-Read-in-Data","page":"Introduction to VIDA","title":"Step 1 Read in Data","text":"","category":"section"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"VIDA currently only works with fits images. THe fits header is based off of what eht-imaging outputs. So as long as you stick to that standard you should be fine.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"To read in an image we just use the load_fits function which should work with any fits image from ehtim and clean","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"img = load_image(joinpath(dirname(pathof(VIDA)),\"../example/data/example_image.fits\"));\nnothing #hide","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"To see what this img is lets print the type","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"println(typeof(img))","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"To plot the image we can just call plot. This uses recipes and the Plots.jl framework","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"plot(img)","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"So from the output we see that img is a EHTImage type. The information in the curly brackets defines the parametric type information. What this means is that the image that is constrained in the EHTImage type is a Matrix whose elements are Float64's.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"Julia isn't a traditional class OOP language. Namely, methods/functions are first class and aren't members of a class. Instead how a function behaves is dependent on the type of argument inputs. This is known as something called multimethods or multiple dispatch where at run-time the type of functions called is determined by the arguments.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"In some sense OOP is just a multiple dispatch type language where the our type of dispatch only depends on the class, i.e. the self argument in Python classes.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"Now because of the lack of classes sometimes it can be difficult to figure out which functions will act of our datatypes, e.g. the EHTImage type. Fortunately, Julia has some convenience functions that let you see which functions/methods can act of the EHTImage type","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"To see what functions can act on an EHTImage object just call","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"methodswith(IntensityMap)","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"From this list we see there are several methods that can act on EHTImage types. To see what a certain function does you can type ?inertia in the terminal to see the help for the inertia method.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"# Creating a divergence","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"In order to find the optimal template you need to first decide on your objective or cost function. In VIDA we use probaility divergences to measure differences between the template and image. A divergence is defined as an abstract type AbstractDivergence. In VIDA a divergence is a functor. A functor is a type that has an anonymous function attached to it. That means it is both a type and a function. For instance we create a divergence by","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"bh = Bhattacharyya(img);\nkl = KullbackLeibler(img);\nnothing #hide","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"Now to evaluate the divergence we need to pass it a template. This can be any template your choose. The great thing about julia is that bh will use multiple dispatch to figure out which template is being passed to the divergence.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"For instance lets create a few different templates","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"gr = GaussianRing(μas2rad(20.0), μas2rad(5.0), 0.0, 0.0)\nggr = EllipticalSlashedGaussianRing(\n                          μas2rad(20.0), #r0\n                          μas2rad(5.0), #σ\n                          0.2, #τ\n                          0.78, #ξτ\n                          0.5, #s\n                          0.78, #ξs\n                          μas2rad(-10.0), #x0\n                          0.0 #y0\n                        )","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"We can also plot both templates","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"a = plot(gr, title=\"GaussianRing\")\nb = plot(ggr, title=\"GeneralGaussianRing\")\nplot(a, b, layout=(1,2), size=(600,300))","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"VIDA has a number of templates defined. These are all subtypes of the AbstractTemplate type. To see which templates are implemented you can use the subtype method:","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"subtypes(VIDA.AbstractImageTemplate)","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"Additionally as of VIDA 0.11 we can also use any VLBISkyModels model and any model that satisfies the interface described here.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"Using VLBISkyModels interface we can also combine templates together","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"add = gr + 2.0*shifted(gr, μas2rad(-10.0), μas2rad(10.0))","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"To evaluate the divergence between our template and image we then just evaluate the divergence on the template","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"@show divergence(kl, add);\n@show divergence(kl, ggr);\n@show divergence(kl, add);\nnothing #hide","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"Now neither template is really a great approximation to the true image. For instance visually they look quite different, which can be checked with the triptic function","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"a = triptic(img, gr)\nb = triptic(img, ggr)\nc = triptic(img, add)\nplot(a,b,c, layout=(3,1), size=(800,800))","category":"page"},{"location":"generated/introduction/#Extracting-the-Optimal-Template","page":"Introduction to VIDA","title":"Extracting the Optimal Template","text":"","category":"section"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"To extract the optimal template the first thing you need to do is define your a function that construct the template and parameterization you will consider","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"function gr_temp(θ)\n    return GaussianRing(θ.r0, θ.σ, θ.x0, θ.y0)\nend","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"We also want to select the domain that we want to search over","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"lower = map(μas2rad, (r0 = 5.0,  σ = 0.01, x0 = -60.0, y0 = -60.0))\nupper = map(μas2rad, (r0 = 60.0, σ = 20.0, x0 = 60.0, y0 = 60.0))\n\nprob = VIDAProblem(bh, gr_temp, lower, upper);\nnothing #hide","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"Now we need to optimize. VIDA uses the Optimization.jl meta package for optimization. That means that we can use any optimization package that works with optimization. For information about possible optimizers see their docs.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"For VIDA the classic optimizer is using the BlackBoxOptim.jl. To use BlackBox optim we need to load the required package","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"using OptimizationBBO","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"However, for this tutorial we will use the BlackBoxOptim optimizer.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"To optimize all you need to do is run the extractor function.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"xopt, optfilt, divmin = vida(prob, BBO_de_rand_1_bin_radiuslimited(); maxiters=100_000)\ntriptic(img, optfilt)","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"Well that seemed to do a terrible job. The reason is that a lot of these images tend to have some low level flux throughout the image. To account for this the template tends to get very big to absorb some of this flux. To combat this you can add a constant background template to the problem.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"gr_temp_cont(θ) = GaussianRing(θ.r0, θ.σ, θ.x0, θ.y0) + θ.f*Constant((μas2rad(100.0)))\nlower = (r0 = μas2rad(5.0),  σ = μas2rad(0.01), x0 = μas2rad(-60.0), y0 = μas2rad(-60.0), f=1e-6)\nupper = (r0 = μas2rad(60.0), σ = μas2rad(20.0), x0 = μas2rad(60.0), y0 = μas2rad(60.0), f=10.0)\nprob = VIDAProblem(bh, gr_temp_cont, lower, upper);\nxopt, optfilt, divmin = vida(prob, BBO_de_rand_1_bin_radiuslimited(); maxiters=50_000)","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"triptic(img, optfilt)","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"That's much better! Now if you wanted to capture the asymmetry in the ring you can use other templates, for example the CosineRing template. Note that this template tends to be a little harder to fit.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"cos_temp(θ) = EllipticalSlashedGaussianRing(θ.r0, θ.σ, θ.τ, θ.ξτ, θ.s, θ.ξs, θ.x0, θ.y0) + θ.f*θ.f*Constant(μas2rad(100.0))\nlower = (r0 = μas2rad(1.0),  σ = μas2rad(0.01), τ=0.0, ξτ=-π/2, s=0.001, ξs=-1π, x0 = μas2rad(-60.0), y0 = μas2rad(-60.0), f=1e-6)\nupper = (r0 = μas2rad(60.0), σ = μas2rad(20.0), τ=0.5, ξτ=π/2, s=0.999, ξs=1π, x0 = μas2rad(60.0), y0 = μas2rad(60.0), f=10.0)\nprob = VIDAProblem(bh, cos_temp, lower, upper);\nxopt, optfilt, divmin = vida(prob, BBO_de_rand_1_bin_radiuslimited(); maxiters=50_000);\nnothing #hide","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"triptic(img, optfilt)","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"Now looks pretty great! To see how to add a custom template see the Adding a Custom Template page.","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"","category":"page"},{"location":"generated/introduction/","page":"Introduction to VIDA","title":"Introduction to VIDA","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#VIDA.jl","page":"Home","title":"VIDA.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Variational image domain analysis for the EHT. This package is for extracting features, such as ring from image reconstruction of EHT data. Currently these images must be in fits format although other types may be included in the future.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"VIDA is a registered Julia package to install","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg; Pkg.add(\"VIDA\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"or go to the repl and simply type ]add VIDA. Note that we require a Julia version >= 1.4.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some additional dependencies that enable full functionality can be added with","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pkg.add.([\"Plots\",\"ArgParse\"])","category":"page"},{"location":"","page":"Home","title":"Home","text":"Plots.jl is required to use some of the plotting recipes defined in the package and ArgParse is used for some of the scripts in the example folder.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To extract features we use probability divergences to characterize differences between our image and some approximation. For the divergences implemented see the Getting Started page. The idea is then very similar to variational inferences where we pick a parametric family of distributions which we call templates and then try to find the template that minimizes the divergence. For the templates that are currently implemented please see the page.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the API for the complete list of documented functions and types.","category":"page"},{"location":"#Outline","page":"Home","title":"Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n  \"index.md\",\n  \"getting_started.md\",\n  \"interface.md\",\n  \"generated/introduction.md\",\n  \"generated/custom_template.md\",\n  \"api/function_index.md\"\n]","category":"page"}]
}
