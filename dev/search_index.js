var documenterSearchIndex = {"docs":
[{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"VIDA is a registered Julia package to install","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Pkg; Pkg.add(\"VIDA\")","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Or go to the repl and simply type ]add VIDA. Note that we require a Julia version >= 1.4.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Some additional dependencies that enable full functionality can be added with","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Pkg.add.([\"Plots\",\"ArgParse\"])","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Plots.jl is required to use some of the plotting recipes defined in the package and ArgParse is used for some of the scripts in the example folder.","category":"page"},{"location":"getting_started/#Idea-behind-VIDA","page":"Getting Started","title":"Idea behind VIDA","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"VIDA is based on the idea of interpreting the image as a probability distribution. Namely since any image is integrable, the space of images is in one-to-one correspondence with a probability distribution.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Therefore, our idea is very close to variational inference, hence the name (the) Variational Image Domain Analysis. Namely, where we view the image as a distribution and we aim to find a approximation of the distribution given some parametric family f_theta(xy), which for our purposes we will typically call a filter.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The choice of filter, depends on the problem of interest, namely what features we are interested in. Typically for the Event Horizon Telescope (EHT) where the images tend to be rings, we are interested in","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Radius r₀\nWidth or half width σ\nStructural asymmetry τ\nFlux asymmetry s\nPosition angle ξ","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"VIDA then defines a series of filters parameterize these features.","category":"page"},{"location":"getting_started/#Filters","page":"Getting Started","title":"Filters","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Currently we have 6 filters defined, although they all belong to the same family. For an example on how to see the process for defining your own filter please see the readme.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The filters implemented are:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"CosineRing{N,M} which defines a ring with a cosine expansion in azimuthal thickness (order N) and brightness (order M).\nGaussianRing which is a symmetric and circular Gaussian ring.\nSlashedGaussianRing which is a circular Gaussian ring with a flux gradient across its emission.\nEllipticalGaussianRing symmetric Gaussian elliptical ring, where the emission is constant across the ring, unlike with the SlashedGaussianRing.\nGeneralGaussianRing A combination of the two above where the ring is allowed to be elliptical and have a intensity gradient.\nTIDAGaussianRing The GeneralGaussianRing, but where the asymmetry and flux orienation are fixed relative to one another.\nAsymGaussian A asymmetric Gaussian blob. This can be useful if you image has a strong non-ring component in it.\nConstant Adds a constant flux floor to the image. This is very helpful for image reconstructions that tend to add small scale flux everywhere in the image.","category":"page"},{"location":"getting_started/#Divergences","page":"Getting Started","title":"Divergences","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"In order to extract features we first need a cost function that penalized our parameterized distributions f_theta(xy). Since we are considering the image as a probability distribution, one cost function would be the distance or divergence between two distributions. A probability divergence is just a functional that takes in two probability distributions p,q and is minimized iff pequiv q. ","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Divergences are defined by the abstract type AbstractDivergence. Implementations of the this type are also expected to implement a functor that evaluates the divergence on some filter. For an example see the implementation of the divergences in ","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Currently we have two divergences implemented in VIDA","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Bhattacharyya divergence (Bh)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":" Bh(f_thetaI) = int sqrtf_theta(xy)I(xy) dxdy","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"KL divergence ","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":" KL(f_thetaI) = int f_theta(xy)logleft(fracf_theta(xy)I(xy)right)dxdy ","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Both divergences give very similar answers, although we found the BH to be easier to maximize.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"For an example of how all this all works is given in the examples folder.","category":"page"},{"location":"function_index/#API","page":"API","title":"API","text":"","category":"section"},{"location":"function_index/","page":"API","title":"API","text":"","category":"page"},{"location":"function_index/","page":"API","title":"API","text":"Modules = [VIDA]","category":"page"},{"location":"function_index/#VIDA.VIDA","page":"API","title":"VIDA.VIDA","text":"VIDA\n\nIs a image feature extraction tool for use with EHT images of black holes. It assumes that the image is close to one of the filters we have implemented and then tries to extract that feature from the image using one of the probability divergences implemented.\n\n\n\n\n\n","category":"module"},{"location":"function_index/#VIDA.AbstractDivergence","page":"API","title":"VIDA.AbstractDivergence","text":"abstract type AbstractDivergence\n\nAn abstract class for a divergence of a function. This is defined in terms of an Image type object. For two examples see below\n\n\n\n\n\n","category":"type"},{"location":"function_index/#VIDA.AbstractFilter","page":"API","title":"VIDA.AbstractFilter","text":"abstract type AbstractFilter\n\nAn absract type that will contain the filter information, such as the parameters. Specific instanstantiations will need to be defined for you to use this.\n\nDetails\n\nThis defined the highest function type. If you wish to implement your own filter you\nneed to define a a couple of things\n1. The filter type <: AbstractFilter\n2. an functor of the type that computes the filter function\n3. an `size` function that defines the number of parameters of the filter.\n\nAn example is given by:\n\n#All of our composite type are defined using the Paramters.jl package to you\ncan directly refer to the struct parameters when creating it, although this isn't\nactually used anywhere in the code.\n@with_kw struct Gaussian <: AbstractFilter\n    σ::Float64\n    x0::Float64\n    y0::Float64\nend\n\n#Typically we inline and force the function to use fastmath\n@fastmath @inline function (θ::Gaussian)(x,y)\n    return 1.0/(2π*σ^2)*exp(-0.5*( (x-x0)^2+(y-y0)^2 ) )\nend\nsize(::Type{Gaussian}) = 3\n\n\n\n\n\n","category":"type"},{"location":"function_index/#VIDA.AbstractFitsImage","page":"API","title":"VIDA.AbstractFitsImage","text":"An absract image that will hold a fits image after being created or parsed in. This will form the basis for most astronomical images that are defined.\n\n\n\n\n\n","category":"type"},{"location":"function_index/#VIDA.AbstractImage","page":"API","title":"VIDA.AbstractImage","text":"An abstact type that acts as a wrapper for image objects used in astronomy.\n\nThis is the top of the castle for images and will be rarely touched. Basically unless you don't want to use fits images this will not be used\n\n\n\n\n\n","category":"type"},{"location":"function_index/#VIDA.AddFilter","page":"API","title":"VIDA.AddFilter","text":"struct AddFilter{T1<:VIDA.AbstractFilter, T2<:VIDA.AbstractFilter} <: VIDA.AbstractFilter\n\nCombines two filters together into one object. Since addition is assoiciative this can actually we used to hold multiple different filters.\n\nDetails\n\nOverloads the Base.:+ function so you can easily add two filters together.\n\nExample\n\nθ1 = GaussianRing(10,5,0,0)\nθ2 = SlashedGaussianRing(15,5,0.5,π/4,0,0)\nθ12 = θ1+θ2\n\n\n\n\n\n","category":"type"},{"location":"function_index/#VIDA.AsymGaussian","page":"API","title":"VIDA.AsymGaussian","text":"struct AsymGaussian <: VIDA.AbstractFilter\n\nAn asymmetric Gaussian blob.\n\nDetails\n\nDefines a asymmetric Gaussian image. This is useful if the image has some non-ring emission in the and you need to soak up some of the flux.\n\nThe parameters of the model follow very closely to those used in Themis. The Gaussian size σ is given by     σ = √(σxσy)     τ = 1-σy/σx, where σx,σy are the semi-major,minor axis lenght respectively. This is similar to how the asymmetry for the EllipticalGaussianRing.\n\nFields\n\nσ\nGaussian size in μas\nτ\nGaussian asymmetry\nξ\nGaussian orientation in radians measured north of east\nx0\nx position of Gaussian center in μas\ny0\ny position of Gaussian center in μas\n\n\n\n\n\n","category":"type"},{"location":"function_index/#VIDA.BBO","page":"API","title":"VIDA.BBO","text":"struct BBO <: VIDA.Optimizer\n\nDefines the interface for the BlackBoxOptim interface. This requires that the user to have imported the BlackBoxOptim package.\n\nFields\n\npopsize: The population size DEFAULT 64\nmaxevals: The maximum number of times to evaluate the divergence before terminiation.\ntracemode: The output option. Default is silent, i.e. no output.\n\nOther options are :compact and :verbose\n\nNotes\n\nThis uses the default BlackBoxOptim optimizer i.e. adaptivederand1bin_radiuslimited. Currently other options aren't implemented since I found that this version tended to work the best.\n\nFields\n\nmethod\nDefault: :adaptivederand1bin_radiuslimited\npopsize\nDefault: 64\nmaxevals\nDefault: 25000\ntracemode\nDefault: :compact\n\n\n\n\n\n","category":"type"},{"location":"function_index/#VIDA.Bhattacharyya","page":"API","title":"VIDA.Bhattacharyya","text":"struct Bhattacharyya{T, S} <: VIDA.AbstractDivergence\n\nType for the Bhattacharyya divergence. It constructed from an EHTImage i.e. data. Additionally to evaluate the divergence we use a functor approach where if θ is your\n\nDetails\n\nThis computes the Bhattacharyya divergence which is related to Hellinger distance between two distributions. In fact, they are both minimized at the same point. The Bhattacharyya divergence is defined as\n\nBh(f_thetahatI) = -logint sqrtf_theta(xy)hatI(xy)dxdy\n\nwhere hatI is defined as the image normalized to unit flux.\n\n\n\n\n\n","category":"type"},{"location":"function_index/#VIDA.CMAES","page":"API","title":"VIDA.CMAES","text":"struct CMAES <: VIDA.Optimizer\n\nDefines the interface for the LBFGS-B interface from the Optim.jl package. This requires that the user to have imported the CMAEvolutionStrategy package.\n\nTypically I have found that this works very well. This the usual first optimizer to try.\n\nFields\n\npopsize\nPopulationSize  Default: 64\ncov_scale\nInitial covariance scale  Default: 1.0\nftarget\ntarget divergence values. nothing means there is no target  Default: nothing\nxtol\nxtol Default: nothing\nftol\nftol Default: 1.0e-11\nmaxevals\nmaximum number of divergence evals, nothing means run until termination Default: nothing\nverbosity\nverbosity of output Default: 1\n\n\n\n\n\n","category":"type"},{"location":"function_index/#VIDA.Constant","page":"API","title":"VIDA.Constant","text":"struct Constant <: VIDA.AbstractFilter\n\nAn constant filter.\n\nDetails\n\nDefines an image that just has constant flux. This is very useful for soaking up low levels of flux in image reconstructions that can bias the results.\n\nSince images or normalized to unity, this means the Constant filter has no additional parameters.\n\n\n\n\n\n","category":"type"},{"location":"function_index/#VIDA.CosineRing","page":"API","title":"VIDA.CosineRing","text":"struct CosineRing{N, M} <: VIDA.AbstractFilter\n\nExtrememly flexible ring model. The thickness is modeled as a cosine expansion with N terms and the slash by a expansion with M terms.\n\nDetails\n\nThe ring is allowed to be elliptical. The thickness of the ring is modeled by a cosine expansion in azimuthal angle. N specifies the number of cosine modes to fit, where the first mode is the constant thickness portion and so has no corresponding angle. The slash is modeled as a separate cosine expansion, with M terms. Here the zero order term is forced to be unity, so M defines the M additional terms.\n\n\n\n\n\n","category":"type"},{"location":"function_index/#VIDA.CosineRing-Union{Tuple{AbstractArray}, Tuple{M}, Tuple{N}} where M where N","page":"API","title":"VIDA.CosineRing","text":"CosineRing{N,M}(p::AbstractArray) where {N,M}\n\nTakes in a vector of paramters describing the filter.\n\nDetails\n\nThe order of the vector must be\n\np[1] = r0\np[2:(N+1)] = σ\np[(N+2):(2N)] = ξσ\np[2N+1] = τ\np[2N+2] = ξτ\np[2N+3:2N+M+2] = s\np[2N+3+M:2N+2+2M] = ξs\np[2N+3+2M] = x0\np[2N+4+2M] = y0\n\n\n\n\n\n","category":"method"},{"location":"function_index/#VIDA.Disk","page":"API","title":"VIDA.Disk","text":"struct Disk <: VIDA.AbstractFilter\n\nA smoothed disk model\n\nDetails\n\nDefines a filter for an image that has a smoothed disk model.\n\n\n\n\n\n","category":"type"},{"location":"function_index/#VIDA.EHTImage","page":"API","title":"VIDA.EHTImage","text":"struct EHTImage{T} <: VIDA.AbstractFitsImage{T}\n\nDetails\n\nThe trait is to hold a EHT image tyically in matrix form. Namely the trait will typically be Matrix{Float64}.\n\nnx is the number of pixels in the x or RA direction ny is the number of pixels in the y or DEC direction psize_x, psize_y are the pixel sizes in the x and y direction source is the source we are looking at e.g. M87 ra,dec are the sources RA and DEC in J2000 coordinates using degrees wavelength is the wavelength of the image. mjd is the Modified Julian Date of the observation. img is the actual pixeled image in Jy/pixel\n\n\n\n\n\n","category":"type"},{"location":"function_index/#VIDA.EHTMovie","page":"API","title":"VIDA.EHTMovie","text":"struct EHTMovie{T<:Interpolations.AbstractExtrapolation} <: VIDA.AbstractMovie\n\nDetails\n\nThe type is to hold a EHT movie. The dimension of the movie array is assumed to be in the form DEC,RA,Time.\n\nnx is the number of pixels in the x or RA direction ny is the number of pixels in the y or DEC direction psize_x, psize_y are the pixel sizes in the x and y direction source is the source we are looking at e.g. M87 ra,dec are the sources RA and DEC in J2000 coordinates using degrees wavelength is the wavelength of the image. mjd is the Modified Julian Date of the observation. frames is the interpolation object that hold the movie frames\n\n\n\n\n\n","category":"type"},{"location":"function_index/#VIDA.EllipticalGaussianRing","page":"API","title":"VIDA.EllipticalGaussianRing","text":"struct EllipticalGaussianRing <: VIDA.AbstractFilter\n\nImplements the elliptical gaussian ring filter. Where the ellipticity tau is defined as one minus ratio between the semi-minor and semi-major axis.\n\nDetails\n\nAdds ellipticity to the ring. The radius r0 of the ring is now defined as the geometric mean of the semi-major (a) and semi-minor (b) axis lengths i.e.\n\nr0 = √(a*b).\n\nThe ellipticity τ is given by τ = 1-b/a.\n\nFields\n\nr0\nRadius of the Gaussian ring\nσ\nStandard deviation of the width of the Gaussian ring\nτ\nAsymmetry of the Gaussian ring defined as 1-ba\nξ\nAsymmetry orientation in radians measured north of east\nx0\nx position of the center of the ring in μas\ny0\ny position of the center of the ring in μas\n\nNotes\n\nThere is no normalization since the ellipticity makes it impossible to normalize analytically. In fact the distance from the ellipse is implemented numerically using an algorithm adapted from git\n\n\n\n\n\n","category":"type"},{"location":"function_index/#VIDA.ExtractProblem","page":"API","title":"VIDA.ExtractProblem","text":"ExtractProblem{T<:AbstractDivergence, S<:AbstractFilter}\n\nDefines a feature extraction problem to minimize, with an abstract filte and an abstract divergence. This is needed to interface with the extractor minimizer, which will minimize the divergence to find the optimal filter.\n\nFields\n\ndiv\nDivergence function to minimize\nθinit\nInitial location of the optimizer\nθlower\nLower bound of the search region\nθupper\nUpper bound of the search region\n\n\n\n\n\n","category":"type"},{"location":"function_index/#VIDA.GaussianRing","page":"API","title":"VIDA.GaussianRing","text":"struct GaussianRing <: VIDA.AbstractFilter\n\nSymmetric gaussian ring filter. This is the most basic filter and just attempts to recover a location x0,y0, radius r0 and thickness σ from some image.\n\nFields\n\nr0\nRadius of Gaussian ring in μas\nσ\nStandard deviation of Gaussian ring in μas\nx0\nx location of the center of the Gaussian ring in μas\ny0\ny location of the center of the Gaussian ring in μas\n\nExample\n\nGaussianRing(r0=20.0,σ=5.0,x0=0.0,y0=-10.0)\n\n\n\n\n\n","category":"type"},{"location":"function_index/#VIDA.GeneralGaussianRing","page":"API","title":"VIDA.GeneralGaussianRing","text":"struct GeneralGaussianRing <: VIDA.AbstractFilter\n\nCreates the most general elliptical slashed gaussian ring model. It is a combination of the elliptical and slashed gaussian ring. The direction of the slash and the ellipticity are not aligned or anti-aligned like with the TIDAGaussianRing type.\n\nDetails\n\nAdds ellipticity to the ring. The radius r0 of the ring is now defined as the geometric mean of the semi-major (a) and semi-minor (b) axis lengths i.e.\n\nr0 = √(a*b).\n\nThe ellipticity τ is given by τ = 1-b/a.\n\nFields\n\nr0\nRadius of the Gaussian ring\nσ\nStandard deviation of the width of the Gaussian ring\nτ\nAsymmetry of the Gaussian ring defined as 1-ba\nξτ\nAsymmetry orientation in radians, measured north of east\ns\nSlash of Gaussian ring.\nξs\nSlash orientation in radians measured north of east\nx0\nx position of the center of the ring in μas\ny0\ny position of the center of the ring in μas\n\n\n\n\n\n","category":"type"},{"location":"function_index/#VIDA.KullbackLeibler","page":"API","title":"VIDA.KullbackLeibler","text":"struct KullbackLeibler{T, S} <: VIDA.AbstractDivergence\n\nType for the KL divergence. It constructed from an EHTImage i.e. data. Additionally to evaluate the divergence we use a functor approach where if θ is your\n\nDetails\n\nThis computes the KL divergence which is related to Hellinger distance between two distributions. In fact, they are both minimized at the same point. The Bhattacharyya divergence is defined as\n\nKL(f_thetahatI) = -logint f_theta(xy)log\n        left(fracf_theta(xy)hatI(xy)rightdxdy\n\nwhere hatI is defined as the image normalized to unit flux.\n\nThis struct is also a functor. ```\n\n\n\n\n\n","category":"type"},{"location":"function_index/#VIDA.MulFilter","page":"API","title":"VIDA.MulFilter","text":"struct MulFilter{T<:VIDA.AbstractFilter, S<:Number} <: VIDA.AbstractFilter\n\nMultiplies filter by a constant. This is useful when combining with AddFilter since it will change the relative weights of each filter.\n\nDetails\n\nOverloads the Base.:* function so you can easily multiple a filter by a number.\n\nExample\n\nθ = GaussianRing(15,5,0.0,0.0)\n2*θ\n\n\n\n\n\n","category":"type"},{"location":"function_index/#VIDA.Opt","page":"API","title":"VIDA.Opt","text":"struct Opt{O<:Optim.AbstractConstrainedOptimizer} <: VIDA.Optimizer\n\nDefines the interface for the LBFGS-B interface from the Optim.jl package. This requires that the user to have imported the Optim package.\n\nFields\n\nopt\noptions\nDefault: Optim.Options()\n\n\n\n\n\n","category":"type"},{"location":"function_index/#VIDA.Optimizer","page":"API","title":"VIDA.Optimizer","text":"abstract type Optimizer\n\nAbstract optimizer class that defines the optimizer to use. This is the interface I'll need to define all the different optimizer classes below.\n\n\n\n\n\n","category":"type"},{"location":"function_index/#VIDA.SlashedGaussianRing","page":"API","title":"VIDA.SlashedGaussianRing","text":"struct SlashedGaussianRing <: VIDA.AbstractFilter\n\nImplements the slashed gaussian ring filter, that uses a cosine to symmetrically implement the slash. While this is marginally more complicated that a linear slash, it has a number of benefits such as mainting the azimuthal and smooth structure of the image.\n\nFields\n\nr0\nRadius of the ring in μas\nσ\nStandard deviation of Gaussian ring in μas\ns\nSlash strength of Gaussiang ring. 0 means no slash\nξ\nRotation angle in radians of slash direction, measured north of west\nx0\nx position of the center of the ring in μas\ny0\ny position of the center of the ring in μas\n\n\n\n\n\n","category":"type"},{"location":"function_index/#VIDA.TIDAGaussianRing","page":"API","title":"VIDA.TIDAGaussianRing","text":"struct TIDAGaussianRing <: VIDA.AbstractFilter\n\nCreates the filter from the Paper I am writing. It is a combination of the elliptical and slashed gaussian ring. The slash and the semi-major axis are either aligned if the slash parameter s>0 or antialigned if s<0.\n\nDetails\n\nAdds ellipticity to the ring. The radius r0 of the ring is now defined as the geometric mean of the semi-major (a) and semi-minor (b) axis lengths i.e.\n\nr0 = √(a*b).\n\nThe ellipticity τ is given by τ = 1-b/a.\n\nFields\n\nr0\nRadius of the Gaussian ring\nσ\nStandard deviation of the width of the Gaussian ring\nτ\nAsymmetry of the Gaussian ring defined as 1-ba\ns\nSlash of Gaussian ring.\nξ\nSlash/Asymmetry orientation in radians measured north of east\nx0\nx position of the center of the ring in μas\ny0\ny position of the center of the ring in μas\n\n\n\n\n\n","category":"type"},{"location":"function_index/#Base.size-Tuple{EHTImage}","page":"API","title":"Base.size","text":"size(img::EHTImage)\n\nFinds the size of the image, i.e. the number of pixels in the y and x directions\n\nReturns: (npixy, npixx)\n\n\n\n\n\n","category":"method"},{"location":"function_index/#Base.split-Tuple{VIDA.AbstractFilter}","page":"API","title":"Base.split","text":"split(θ)\n\n\nSplits the filter into an array with its subcomponents so you can easily access them.\n\n\n\n\n\n","category":"method"},{"location":"function_index/#VIDA.blur-Tuple{EHTImage,Any}","page":"API","title":"VIDA.blur","text":"blur(img, fwhm)\n\n\nBlurs the img with a gaussian kernel with fwhm in μas. If fwhm is a scalar then the kernel is assumed to be symmetric, otherwise you the first entry is the fwhm in the EW direction and second the NS direction.\n\nReturns the blurred image.\n\n\n\n\n\n","category":"method"},{"location":"function_index/#VIDA.blur-Tuple{EHTMovie,Any}","page":"API","title":"VIDA.blur","text":"blur(mov, fwhm)\n\n\nBlurs the mov with a gaussian kernel with fwhm in μas. If fwhm is a scalar then the kernel is assumed to be symmetric, otherwise you the first entry is the fwhm in the EW direction and second the NS direction.\n\nReturns the blurred movie.\n\n\n\n\n\n","category":"method"},{"location":"function_index/#VIDA.centroid-Tuple{EHTImage}","page":"API","title":"VIDA.centroid","text":"centroid(img)\n\n\nFinds the centroid or center of light of the img in μas.\n\n\n\n\n\n","category":"method"},{"location":"function_index/#VIDA.clipimage","page":"API","title":"VIDA.clipimage","text":"clipimage(clip, im)\nclipimage(clip, im, mode)\n\n\nClips the image im according to the value clip, which can either be an absolute flux in Jy/px or the intensity relative to the maximum.\n\n\n\n\n\n","category":"function"},{"location":"function_index/#VIDA.downsample-Tuple{Int64,EHTImage}","page":"API","title":"VIDA.downsample","text":"downsample(factor, im)\n\n\nDown samples the image im by a factor\n\nDetails\n\nGiven an image im with Nxtimes Ny pixels, downsample converts that to an image with Nxfactor times Nyfactor pixels. This can be useful when the image has much higher resolutions than is needed for feature extraction.\n\n\n\n\n\n","category":"method"},{"location":"function_index/#VIDA.extractor-Tuple{Any,Any}","page":"API","title":"VIDA.extractor","text":"extractor(prob::ExtractProblem, optimizer::Optimizer)\n\nThis extracts the optimal filter defined by the prob problem. This will minimize the divergence in prob and return the optimal filter and minimum divergence in a tuple.\n\noptimizer is one of VIDA's optimizer types. Typically I would recommend the BBO() optimizer\n\nExamples\n\n    θopt, divmin = extractor(prob, BBO())\n\n\n\n\n\n","category":"method"},{"location":"function_index/#VIDA.field_of_view-Tuple{EHTImage}","page":"API","title":"VIDA.field_of_view","text":"field_of_view(img::EHTImage)\n\nFinds the field of view of an EHTImage. Return a w element tuple with the field of view in the x and y direction\n\n\n\n\n\n","category":"method"},{"location":"function_index/#VIDA.filter_image-Tuple{VIDA.AbstractFilter,Int64,Any,Any}","page":"API","title":"VIDA.filter_image","text":"filter_image(θ, npix, xlim, ylim)\n\n\nCreates an npix×npix rasterized image of the filter θ with limits xlim and ylim\n\nReturns the tuple (xitr,yitr,image) where xitr,yitr are the iterators defining the pixel locations (which are centered) and the rasterized image,  in Jy/μas^2.\n\nNote\n\nI use the pixel size definition fieldofview/npix, but the image is evaluated at the pixel centers.\n\nWe also use the astronomer orientation and ordering.\n\n\n\n\n\n","category":"method"},{"location":"function_index/#VIDA.flux-Tuple{Any,Any}","page":"API","title":"VIDA.flux","text":"flux(mov, t)\n\n\nReturns the flux of the mov at the times time in fractional hours\n\n\n\n\n\n","category":"method"},{"location":"function_index/#VIDA.flux-Tuple{EHTImage}","page":"API","title":"VIDA.flux","text":"flux(img)\n\n\nFinds the image flux of an EHTImage img\n\n\n\n\n\n","category":"method"},{"location":"function_index/#VIDA.get_frames-Tuple{EHTMovie}","page":"API","title":"VIDA.get_frames","text":"get_frames(mov)\n\n\nGets all the frames of the movie object mov. This returns a array of EHTImage objects.\n\n\n\n\n\n","category":"method"},{"location":"function_index/#VIDA.get_image-Tuple{EHTMovie,Any}","page":"API","title":"VIDA.get_image","text":"get_image(mov, t)\n\n\nGets the frame of the movie object mov at the time t. This returns an EHTImage object at the requested time. The returned object is found by linear interpolation.\n\n\n\n\n\n","category":"method"},{"location":"function_index/#VIDA.get_radec-Tuple{T} where T<:VIDA.AbstractFitsImage","page":"API","title":"VIDA.get_radec","text":"get_radec(img::T) <: AbstractFitsImage\n\nReturns two iterators (ra,dec) that give the locations of the img pixels.\n\n\n\n\n\n","category":"method"},{"location":"function_index/#VIDA.get_times-Tuple{EHTMovie}","page":"API","title":"VIDA.get_times","text":"get_times(mov)\n\n\nReturns the times that the movie object mov was created at. This does not have to be uniform in time.\n\n\n\n\n\n","category":"method"},{"location":"function_index/#VIDA.inertia","page":"API","title":"VIDA.inertia","text":"inertia(img)\ninertia(img, center)\n\n\nFind the image moment of inertia or second moment\n\nNotes\n\nIf center=true then we find the central second moment, or the second cumulant of the image.\n\n\n\n\n\n","category":"function"},{"location":"function_index/#VIDA.join_frames-Union{Tuple{T}, Tuple{Any,Array{T,1}}} where T<:EHTImage","page":"API","title":"VIDA.join_frames","text":"join_frames(times, images)\n\n\nJoins an array of EHTImages at specified times to form an EHTMovie object.\n\nInputs\n\ntimes: An array of times that the image was created at\nimages: An array of EHTImage objects\n\nOutputs\n\nEHTMovie object\n\n\n\n\n\n","category":"method"},{"location":"function_index/#VIDA.load_ehtimfits-Tuple{String}","page":"API","title":"VIDA.load_ehtimfits","text":"load_ehtimfits(fits_name)\n\n\nwhere fits_name should be a fits file generated using ehtim\n\nDetails\n\nThis reads in a fits file created using ehtim. This is because ehtim only outputs the image and not a separate HDU for the field, so the usual fits reader doesn't work properly.\n\nThe function returns an EHTImage object that contains the relevant image and parameters extracted from the fits file. It also ensures that we are astronomers and that the image using sky-left coordinates.\n\n\n\n\n\n","category":"method"},{"location":"function_index/#VIDA.load_fits-Tuple{String}","page":"API","title":"VIDA.load_fits","text":"load_fits(fits_name)\n\n\nwhere fits_name should be a fits file generated using ehtim\n\nDetails\n\nThis reads in a fits file that is more robust to the various imaging algorithms in the EHT, i.e. is works with clean, smili, eht-imaging.\n\nThe function returns an EHTImage object that contains the relevant image and parameters extracted from the fits file. It also ensures that we are astronomers and that the image using sky-left coordinates.\n\n\n\n\n\n","category":"method"},{"location":"function_index/#VIDA.load_hdf5-Tuple{Any}","page":"API","title":"VIDA.load_hdf5","text":"load_hdf5(filename; style)\n\n\nLoads an hdf5 file where filename should be a HDF5 file.\n\nDetails\n\nThis reads in a hdf5 file and outputs and EHTMovie object.\n\nNotes\n\nCurrently this only works with movies created by ehtim. SMILI uses a different format, as does Illinois, and every other group.\n\n\n\n\n\n","category":"method"},{"location":"function_index/#VIDA.rescale-Tuple{EHTImage,Any,Any,Any}","page":"API","title":"VIDA.rescale","text":"rescale(img::EHTImage, npix, xlim, ylim)\n\nInputs\n\nimg::EHTImage : Image you want to rescale\nnpix : Number of pixels in x and y direction\nxlim : Tuple with the limits of the image in the RA\nylim : Tuple with the limits of the image in DEC\n\n\n\n\n\n","category":"method"},{"location":"function_index/#VIDA.rescale-Tuple{EHTMovie,Any,Any,Any}","page":"API","title":"VIDA.rescale","text":"rescale(img::EHTMovie, npix, xlim, ylim)\n\nInputs\n\nimg::EHTImage : Image you want to rescale\nnpix : Number of pixels in x and y direction\nxlim : Tuple with the limits of the image in the RA\nylim : Tuple with the limits of the image in DEC\n\n\n\n\n\n","category":"method"},{"location":"function_index/#VIDA.save_fits-Tuple{EHTImage,String}","page":"API","title":"VIDA.save_fits","text":"save_fits(image::EHTImage, fname::String)\n\nSave the image as a fits object with filename fname\n\n\n\n\n\n","category":"method"},{"location":"function_index/#VIDA.save_hdf5-Tuple{Any,Any}","page":"API","title":"VIDA.save_hdf5","text":"save_hdf5(filename, mov; style)\n\n\nSaves and hdf5 file where filename is the write out location. Currently style only works with ehtim, namely we save HDF5 files that only work with ehtim.\n\n\n\n\n\n","category":"method"},{"location":"function_index/#VIDA.stack-Union{Tuple{T}, Tuple{T,Vararg{Any,N} where N}} where T<:VIDA.AbstractFilter","page":"API","title":"VIDA.stack","text":"stack(θ, θ1)\n\n\nStacks filters together so you can easily combine multiple filters. It does this by calling the :+ and :* method. Every filter added will include an additional parameter that controls the relative weight of each filter.\n\n\n\n\n\n","category":"method"},{"location":"function_index/#VIDA.threaded_extractor-Union{Tuple{T}, Tuple{S2}, Tuple{S1}, Tuple{Int64,ExtractProblem{S1,S2},T}} where T<:VIDA.Optimizer where S2 where S1","page":"API","title":"VIDA.threaded_extractor","text":"threaded_extractor(nstart::Int, prob::ExtractProblem, optimizer::Optimizer)\n\nA threaded multi-start version of the extractor method. This will run nstart instances of extractor, where the initial location of chosen uniformly within the bounds defined in prob.\n\nOutputs\n\nThis outputs the best filter and minimum divergence of all the extractors run.\n\n\n\n\n\n","category":"method"},{"location":"function_index/#VIDA.unpack-Tuple{T} where T<:VIDA.AbstractFilter","page":"API","title":"VIDA.unpack","text":"Unpacks the parameters of the filter θ\n\nReturns the parameters in a vector.\n\n\n\n\n\n","category":"method"},{"location":"function_index/#VIDA.window_image-Tuple{Any,Any,EHTImage}","page":"API","title":"VIDA.window_image","text":"window_image(domain_x, domain_y, im)\n\n\nGiven an image im it selects a new field of view for the image given by domain_x, domain_y.\n\n\n\n\n\n","category":"method"},{"location":"#VIDA.jl","page":"Home","title":"VIDA.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Variational image domain analysis for the EHT.  This package is for extracting features, such as ring from image reconstruction of EHT data. Currently these images must be in fits format although other types  my be included in the future.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In order to extract features we use probability divergences to characterize differences between our image and some approximation. For the divergences implemented see the Getting Started page. The idea is then very  similar to variational inferences where we pick a parametric family of distributions which we call filters and then try to find the filter that minimizes the divergence. For the filters that are currently implemented  please see the page.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the for the complete list of documented functions and types.","category":"page"},{"location":"#Outline","page":"Home","title":"Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n  \"index.md\",\n  \"getting_started.md\",\n  \"function_index.md\"\n]","category":"page"}]
}
