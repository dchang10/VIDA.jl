<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · VIDA.jl</title><link rel="canonical" href="https://ptiede.github.io/VIDA.jl/function_index/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">VIDA.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ptiede/VIDA.jl/blob/master/docs/src/function_index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><ul><li><a href="#VIDA.VIDA"><code>VIDA.VIDA</code></a></li><li><a href="#VIDA.AbstractDivergence"><code>VIDA.AbstractDivergence</code></a></li><li><a href="#VIDA.AbstractFilter"><code>VIDA.AbstractFilter</code></a></li><li><a href="#VIDA.AbstractFitsImage"><code>VIDA.AbstractFitsImage</code></a></li><li><a href="#VIDA.AbstractImage"><code>VIDA.AbstractImage</code></a></li><li><a href="#VIDA.AddFilter"><code>VIDA.AddFilter</code></a></li><li><a href="#VIDA.AsymGaussian"><code>VIDA.AsymGaussian</code></a></li><li><a href="#VIDA.Bhattacharyya"><code>VIDA.Bhattacharyya</code></a></li><li><a href="#VIDA.Constant"><code>VIDA.Constant</code></a></li><li><a href="#VIDA.CosineRing"><code>VIDA.CosineRing</code></a></li><li><a href="#VIDA.CosineRing-Union{Tuple{AbstractArray}, Tuple{M}, Tuple{N}} where M where N"><code>VIDA.CosineRing</code></a></li><li><a href="#VIDA.Disk"><code>VIDA.Disk</code></a></li><li><a href="#VIDA.EHTImage"><code>VIDA.EHTImage</code></a></li><li><a href="#VIDA.EllipticalGaussianRing"><code>VIDA.EllipticalGaussianRing</code></a></li><li><a href="#VIDA.GaussianRing"><code>VIDA.GaussianRing</code></a></li><li><a href="#VIDA.GeneralGaussianRing"><code>VIDA.GeneralGaussianRing</code></a></li><li><a href="#VIDA.KullbackLeibler"><code>VIDA.KullbackLeibler</code></a></li><li><a href="#VIDA.MulFilter"><code>VIDA.MulFilter</code></a></li><li><a href="#VIDA.SlashedGaussianRing"><code>VIDA.SlashedGaussianRing</code></a></li><li><a href="#VIDA.TIDAGaussianRing"><code>VIDA.TIDAGaussianRing</code></a></li><li><a href="#Base.cat-Union{Tuple{T}, Tuple{T,Vararg{Any,N} where N}} where T&lt;:VIDA.AbstractFilter"><code>Base.cat</code></a></li><li><a href="#Base.split-Tuple{VIDA.AbstractFilter}"><code>Base.split</code></a></li><li><a href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol,Any},VIDA.Triptic}"><code>RecipesBase.apply_recipe</code></a></li><li><a href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol,Any},VIDA.AbstractFilter}"><code>RecipesBase.apply_recipe</code></a></li><li><a href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol,Any},EHTImage}"><code>RecipesBase.apply_recipe</code></a></li><li><a href="#VIDA.bbextract-Union{Tuple{T}, Tuple{Any,T,Any,Any,Vararg{Any,N} where N}} where T&lt;:VIDA.AbstractFilter"><code>VIDA.bbextract</code></a></li><li><a href="#VIDA.centroid-Tuple{EHTImage}"><code>VIDA.centroid</code></a></li><li><a href="#VIDA.clipimage"><code>VIDA.clipimage</code></a></li><li><a href="#VIDA.contrastboot-Tuple{Any,EHTImage}"><code>VIDA.contrastboot</code></a></li><li><a href="#VIDA.downsample-Tuple{Int64,EHTImage}"><code>VIDA.downsample</code></a></li><li><a href="#VIDA.extract-Union{Tuple{T}, Tuple{Int64,Any,T,Any,Any,Vararg{Any,N} where N}} where T&lt;:VIDA.AbstractFilter"><code>VIDA.extract</code></a></li><li><a href="#VIDA.extract-Union{Tuple{T}, Tuple{Any,T,Any,Any,Vararg{Any,N} where N}} where T&lt;:VIDA.AbstractFilter"><code>VIDA.extract</code></a></li><li><a href="#VIDA.filter_image-Tuple{VIDA.AbstractFilter,Int64,Any,Any}"><code>VIDA.filter_image</code></a></li><li><a href="#VIDA.flux-Tuple{EHTImage}"><code>VIDA.flux</code></a></li><li><a href="#VIDA.inertia"><code>VIDA.inertia</code></a></li><li><a href="#VIDA.load_ehtimfits-Tuple{String}"><code>VIDA.load_ehtimfits</code></a></li><li><a href="#VIDA.unpack-Union{Tuple{T}, Tuple{T}} where T&lt;:VIDA.AbstractFilter"><code>VIDA.unpack</code></a></li><li><a href="#VIDA.window_image-Tuple{Any,Any,EHTImage}"><code>VIDA.window_image</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="VIDA.VIDA" href="#VIDA.VIDA"><code>VIDA.VIDA</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia">VIDA</code></pre><p>Is a image feature extraction tool for use with EHT images of black holes. It assumes that the image is close to one of the filters we have implemented and then tries to extract that feature from the image using one of the probability divergences implemented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/10d52a7caeb9e274223d861a7d2935f528f86435/src/VIDA.jl#LL2-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.AbstractDivergence" href="#VIDA.AbstractDivergence"><code>VIDA.AbstractDivergence</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractDivergence</code></pre><p>An abstract class for a divergence of a function. This is defined in terms of an Image type object. For two examples see below</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/10d52a7caeb9e274223d861a7d2935f528f86435/src/divergences.jl#LL2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.AbstractFilter" href="#VIDA.AbstractFilter"><code>VIDA.AbstractFilter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractFilter</code></pre><p>An absract type that will contain the filter information, such as the parameters. Specific instanstantiations will need to be defined for you to use this.</p><p><strong>Details</strong></p><pre><code class="language-none">This defined the highest function type. If you wish to implement your own filter you
need to define a a couple of things
1. The filter type &lt;: AbstractFilter
2. an functor of the type that computes the filter function
3. an `size` function that defines the number of parameters of the filter.</code></pre><p>An example is given by:</p><pre><code class="language-julia">#All of our composite type are defined using the Paramters.jl package to you
can directly refer to the struct parameters when creating it, although this isn&#39;t
actually used anywhere in the code.
@with_kw struct Gaussian &lt;: AbstractFilter
    σ::Float64
    x0::Float64
    y0::Float64
end

#Typically we inline and force the function to use fastmath
@fastmath @inline function (θ::Gaussian)(x,y)
    return 1.0/(2π*σ^2)*exp(-0.5*( (x-x0)^2+(y-y0)^2 ) )
end
size(::Type{Gaussian}) = 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/10d52a7caeb9e274223d861a7d2935f528f86435/src/filters.jl#LL3-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.AbstractFitsImage" href="#VIDA.AbstractFitsImage"><code>VIDA.AbstractFitsImage</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An absract image that will hold a fits image after being created or parsed in. This will form the basis for most astronomical images that are defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/10d52a7caeb9e274223d861a7d2935f528f86435/src/images.jl#LL9-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.AbstractImage" href="#VIDA.AbstractImage"><code>VIDA.AbstractImage</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An abstact type that acts as a wrapper for image objects used in astronomy.</p><p>This is the top of the castle for images and will be rarely touched. Basically unless you don&#39;t want to use fits images this will not be used</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/10d52a7caeb9e274223d861a7d2935f528f86435/src/images.jl#LL1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.AddFilter" href="#VIDA.AddFilter"><code>VIDA.AddFilter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct AddFilter{T1&lt;:VIDA.AbstractFilter, T2&lt;:VIDA.AbstractFilter} &lt;: VIDA.AbstractFilter</code></pre><p>Combines two filters together into one object. Since addition is assoiciative this can actually we used to hold multiple different filters.</p><p><strong>Details</strong></p><p>Overloads the Base.:+ function so you can easily add two filters together.</p><p><strong>Example</strong></p><pre><code class="language-julia">θ1 = GaussianRing(10,5,0,0)
θ2 = SlashedGaussianRing(15,5,0.5,π/4,0,0)
θ12 = θ1+θ2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/10d52a7caeb9e274223d861a7d2935f528f86435/src/filters.jl#LL635-L649">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.AsymGaussian" href="#VIDA.AsymGaussian"><code>VIDA.AsymGaussian</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct AsymGaussian &lt;: VIDA.AbstractFilter</code></pre><p>An asymmetric Gaussian blob.</p><p><strong>Details</strong></p><p>Defines a asymmetric Gaussian image. This is useful if the image has some non-ring emission in the and you need to soak up some of the flux.</p><p>The parameters of the model follow very closely to those used in Themis. The Gaussian size <code>σ</code> is given by     σ = √(σxσy)     τ = 1-σy/σx, where σx,σy are the semi-major,minor axis lenght respectively. This is similar to how the asymmetry for the <code>EllipticalGaussianRing</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>σ</code></p><p>Gaussian size in μas</p></li><li><p><code>τ</code></p><p>Gaussian asymmetry</p></li><li><p><code>ξ</code></p><p>Gaussian orientation in radians measured north of east</p></li><li><p><code>x0</code></p><p>x position of Gaussian center in μas</p></li><li><p><code>y0</code></p><p>y position of Gaussian center in μas</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.Bhattacharyya" href="#VIDA.Bhattacharyya"><code>VIDA.Bhattacharyya</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Bhattacharyya{T, S} &lt;: VIDA.AbstractDivergence</code></pre><p>Type for the Bhattacharyya divergence. It constructed from an <code>EHTImage</code> i.e. data. Additionally to evaluate the divergence we use a functor approach where if θ is your</p><p><strong>Details</strong></p><p>This computes the Bhattacharyya divergence which is related to Hellinger distance between two distributions. In fact, they are both minimized at the same point. The Bhattacharyya divergence is defined as</p><div>\[Bh(f_\theta||\hat{I}) = -\log\int \sqrt{f_\theta(x,y)\hat{I}(x,y)}dxdy,\]</div><p>where <span>$\hat{I}$</span> is defined as the image normalized to unit flux.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/10d52a7caeb9e274223d861a7d2935f528f86435/src/divergences.jl#LL9-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.Constant" href="#VIDA.Constant"><code>VIDA.Constant</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Constant &lt;: VIDA.AbstractFilter</code></pre><p>An constant filter.</p><p><strong>Details</strong></p><p>Defines an image that just has constant flux. This is very useful for soaking up low levels of flux in image reconstructions that can bias the results.</p><p>Since images or normalized to unity, this means the <code>Constant</code> filter has no additional parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/10d52a7caeb9e274223d861a7d2935f528f86435/src/filters.jl#LL37-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.CosineRing" href="#VIDA.CosineRing"><code>VIDA.CosineRing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct CosineRing{N, M} &lt;: VIDA.AbstractFilter</code></pre><p>Extrememly flexible ring model. The thickness is modeled as a cosine expansion with <code>N</code> terms and the slash by a expansion with <code>M</code> terms.</p><p><strong>Details</strong></p><p>The ring is allowed to be elliptical. The thickness of the ring is modeled by a cosine expansion in azimuthal angle. <code>N</code> specifies the number of cosine modes to fit, where the first mode is the constant thickness portion and so has no corresponding angle. The slash is modeled as a separate cosine expansion, with <code>M</code> terms. Here the zero order term is forced to be unity, so <code>M</code> defines the <code>M</code> additional terms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.CosineRing-Union{Tuple{AbstractArray}, Tuple{M}, Tuple{N}} where M where N" href="#VIDA.CosineRing-Union{Tuple{AbstractArray}, Tuple{M}, Tuple{N}} where M where N"><code>VIDA.CosineRing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CosineRing{N,M}(p::AbstractArray) where {N,M}</code></pre><p>Takes in a vector of paramters describing the filter.</p><p><strong>Details</strong></p><p>The order of the vector must be</p><ul><li>p[1] = <code>r0</code></li><li>p[2:(N+1)] = <code>σ</code></li><li>p[(N+2):(2N)] = <code>ξσ</code></li><li>p[2N+1] = <code>τ</code></li><li>p[2N+2] = <code>ξτ</code></li><li>p[2N+3:2N+M+2] = <code>s</code></li><li>p[2N+3+M:2N+2+2M] = <code>ξs</code></li><li>p[2N+3+2M] = <code>x0</code></li><li>p[2N+4+2M] = <code>y0</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/10d52a7caeb9e274223d861a7d2935f528f86435/src/filters.jl#LL484-L498">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.Disk" href="#VIDA.Disk"><code>VIDA.Disk</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Disk &lt;: VIDA.AbstractFilter</code></pre><p>A smoothed disk model</p><p><strong>Details</strong></p><p>Defines a filter for an image that has a smoothed disk model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.EHTImage" href="#VIDA.EHTImage"><code>VIDA.EHTImage</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct EHTImage{T} &lt;: VIDA.AbstractFitsImage{T}</code></pre><p><strong>Details</strong></p><p>The trait is to hold a EHT image tyically in matrix form. Namely the trait will typically be Matrix{Float64}.</p><p><code>nx</code> is the number of pixels in the x or RA direction <code>ny</code> is the number of pixels in the y or DEC direction <code>psize_x</code>, <code>psize_y</code> are the pixel sizes in the x and y direction <code>source</code> is the source we are looking at e.g. M87 <code>ra</code>,<code>dec</code> are the sources RA and DEC in J2000 coordinates using degrees <code>wavelength</code> is the wavelength of the image. <code>mjd</code> is the Modified Julian Date of the observation. <code>img</code> is the actual pixeled image in Jy/pixel</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/10d52a7caeb9e274223d861a7d2935f528f86435/src/images.jl#LL15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.EllipticalGaussianRing" href="#VIDA.EllipticalGaussianRing"><code>VIDA.EllipticalGaussianRing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct EllipticalGaussianRing &lt;: VIDA.AbstractFilter</code></pre><p>Implements the elliptical gaussian ring filter. Where the ellipticity <code>tau</code> is defined as one minus ratio between the semi-minor and semi-major axis.</p><p><strong>Details</strong></p><p>Adds ellipticity to the ring. The radius <code>r0</code> of the ring is now defined as the geometric mean of the semi-major (a) and semi-minor (b) axis lengths i.e.</p><p>r0 = √(a*b).</p><p>The ellipticity <code>τ</code> is given by τ = 1-b/a.</p><p><strong>Fields</strong></p><ul><li><p><code>r0</code></p><p>Radius of the Gaussian ring</p></li><li><p><code>σ</code></p><p>Standard deviation of the width of the Gaussian ring</p></li><li><p><code>τ</code></p><p>Asymmetry of the Gaussian ring defined as <span>$1-b/a$</span></p></li><li><p><code>ξ</code></p><p>Asymmetry orientation in radians measured north of east</p></li><li><p><code>x0</code></p><p>x position of the center of the ring in μas</p></li><li><p><code>y0</code></p><p>y position of the center of the ring in μas</p></li></ul><p><strong>Notes</strong></p><p>There is no normalization since the ellipticity makes it impossible to normalize analytically. In fact the distance from the ellipse is implemented numerically using an algorithm adapted from <a href="https://github.com/0xfaded/ellipse_demo/issues/1#issuecomment-405078823">git</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.GaussianRing" href="#VIDA.GaussianRing"><code>VIDA.GaussianRing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct GaussianRing &lt;: VIDA.AbstractFilter</code></pre><p>Symmetric gaussian ring filter. This is the most basic filter and just attempts to recover a location <code>x0</code>,<code>y0</code>, radius <code>r0</code> and thickness <code>σ</code> from some image.</p><p><strong>Fields</strong></p><ul><li><p><code>r0</code></p><p>Radius of Gaussian ring in μas</p></li><li><p><code>σ</code></p><p>Standard deviation of Gaussian ring in μas</p></li><li><p><code>x0</code></p><p>x location of the center of the Gaussian ring in μas</p></li><li><p><code>y0</code></p><p>y location of the center of the Gaussian ring in μas</p></li></ul><p><strong>Example</strong></p><pre><code class="language-julia">GaussianRing(r0=20.0,σ=5.0,x0=0.0,y0=-10.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.GeneralGaussianRing" href="#VIDA.GeneralGaussianRing"><code>VIDA.GeneralGaussianRing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct GeneralGaussianRing &lt;: VIDA.AbstractFilter</code></pre><p>Creates the most general elliptical slashed gaussian ring model. It is a combination of the elliptical and slashed gaussian ring. The direction of the slash and the ellipticity are not aligned or anti-aligned like with the TIDAGaussianRing type.</p><p><strong>Details</strong></p><p>Adds ellipticity to the ring. The radius <code>r0</code> of the ring is now defined as the geometric mean of the semi-major (a) and semi-minor (b) axis lengths i.e.</p><p>r0 = √(a*b).</p><p>The ellipticity <code>τ</code> is given by τ = 1-b/a.</p><p><strong>Fields</strong></p><ul><li><p><code>r0</code></p><p>Radius of the Gaussian ring</p></li><li><p><code>σ</code></p><p>Standard deviation of the width of the Gaussian ring</p></li><li><p><code>τ</code></p><p>Asymmetry of the Gaussian ring defined as <span>$1-b/a$</span></p></li><li><p><code>ξτ</code></p><p>Asymmetry orientation in radians, measured north of east</p></li><li><p><code>s</code></p><p>Slash of Gaussian ring.</p></li><li><p><code>ξs</code></p><p>Slash orientation in radians measured north of east</p></li><li><p><code>x0</code></p><p>x position of the center of the ring in μas</p></li><li><p><code>y0</code></p><p>y position of the center of the ring in μas</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.KullbackLeibler" href="#VIDA.KullbackLeibler"><code>VIDA.KullbackLeibler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct KullbackLeibler{T, S} &lt;: VIDA.AbstractDivergence</code></pre><p>Type for the KL divergence. It constructed from an <code>EHTImage</code> i.e. data. Additionally to evaluate the divergence we use a functor approach where if θ is your</p><p><strong>Details</strong></p><p>This computes the KL divergence which is related to Hellinger distance between two distributions. In fact, they are both minimized at the same point. The Bhattacharyya divergence is defined as</p><div>\[KL(f_\theta||\hat{I}) = -\log\int f_{\theta}(x,y)\log
        \left(\frac{f_{\theta}(x,y)}{\hat{I}(x,y)}\rightdxdy,\]</div><p>where <span>$\hat{I}$</span> is defined as the image normalized to unit flux.</p><p>This struct is also a functor. ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/10d52a7caeb9e274223d861a7d2935f528f86435/src/divergences.jl#LL58-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.MulFilter" href="#VIDA.MulFilter"><code>VIDA.MulFilter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct MulFilter{S&lt;:Number, T&lt;:VIDA.AbstractFilter} &lt;: VIDA.AbstractFilter</code></pre><p>Multiplies filter by a constant. This is useful when combining with AddFilter since it will change the relative weights of each filter.</p><p><strong>Details</strong></p><p>Overloads the Base.:* function so you can easily multiple a filter by a number.</p><p><strong>Example</strong></p><pre><code class="language-julia">θ = GaussianRing(15,5,0.0,0.0)
2*θ</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/10d52a7caeb9e274223d861a7d2935f528f86435/src/filters.jl#LL683-L696">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.SlashedGaussianRing" href="#VIDA.SlashedGaussianRing"><code>VIDA.SlashedGaussianRing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct SlashedGaussianRing &lt;: VIDA.AbstractFilter</code></pre><p>Implements the slashed gaussian ring filter, that uses a cosine to symmetrically implement the slash. While this is marginally more complicated that a linear slash, it has a number of benefits such as mainting the azimuthal and smooth structure of the image.</p><p><strong>Fields</strong></p><ul><li><p><code>r0</code></p><p>Radius of the ring in μas</p></li><li><p><code>σ</code></p><p>Standard deviation of Gaussian ring in μas</p></li><li><p><code>s</code></p><p>Slash strength of Gaussiang ring. 0 means no slash</p></li><li><p><code>ξ</code></p><p>Rotation angle in radians of slash direction, measured north of west</p></li><li><p><code>x0</code></p><p>x position of the center of the ring in μas</p></li><li><p><code>y0</code></p><p>y position of the center of the ring in μas</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.TIDAGaussianRing" href="#VIDA.TIDAGaussianRing"><code>VIDA.TIDAGaussianRing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct TIDAGaussianRing &lt;: VIDA.AbstractFilter</code></pre><p>Creates the filter from the Paper I am writing. It is a combination of the elliptical and slashed gaussian ring. The slash and the semi-major axis are either aligned if the slash parameter <code>s</code>&gt;0 or antialigned if <code>s</code>&lt;0.</p><p><strong>Details</strong></p><p>Adds ellipticity to the ring. The radius <code>r0</code> of the ring is now defined as the geometric mean of the semi-major (a) and semi-minor (b) axis lengths i.e.</p><p>r0 = √(a*b).</p><p>The ellipticity <code>τ</code> is given by τ = 1-b/a.</p><p><strong>Fields</strong></p><ul><li><p><code>r0</code></p><p>Radius of the Gaussian ring</p></li><li><p><code>σ</code></p><p>Standard deviation of the width of the Gaussian ring</p></li><li><p><code>τ</code></p><p>Asymmetry of the Gaussian ring defined as <span>$1-b/a$</span></p></li><li><p><code>s</code></p><p>Slash of Gaussian ring.</p></li><li><p><code>ξ</code></p><p>Slash/Asymmetry orientation in radians measured north of east</p></li><li><p><code>x0</code></p><p>x position of the center of the ring in μas</p></li><li><p><code>y0</code></p><p>y position of the center of the ring in μas</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.cat-Union{Tuple{T}, Tuple{T,Vararg{Any,N} where N}} where T&lt;:VIDA.AbstractFilter" href="#Base.cat-Union{Tuple{T}, Tuple{T,Vararg{Any,N} where N}} where T&lt;:VIDA.AbstractFilter"><code>Base.cat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cat(θ, θ1)
</code></pre><p>Stacks filters together so you can easily combine multiple filters. It does this by calling the :+ and :* method. Every filter added will include an additional parameter that controls the relative weight of each filter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/10d52a7caeb9e274223d861a7d2935f528f86435/src/filters.jl#LL723-L728">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.split-Tuple{VIDA.AbstractFilter}" href="#Base.split-Tuple{VIDA.AbstractFilter}"><code>Base.split</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">split(θ)
</code></pre><p>Splits the filter into an array with its subcomponents so you can easily access them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/10d52a7caeb9e274223d861a7d2935f528f86435/src/filters.jl#LL733-L736">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol,Any},EHTImage}" href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol,Any},EHTImage}"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span></header><section><div><p>plot(image::EHTImage)</p><p>where <code>image</code> is templated off of EHTImage struct.</p><p><strong>Details</strong></p><p>This was created to be close to the ehtim display object. It takes an EHTImage object and plots it according to EHT conventions.</p><p>Note that is does not save the figure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/10d52a7caeb9e274223d861a7d2935f528f86435/src/visualizations.jl#LL37-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol,Any},VIDA.AbstractFilter}" href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol,Any},VIDA.AbstractFilter}"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">plot(θ::AbstractFilter)
plot(θ::AbstractFilter; npix, fovx, fovy)</code></pre><p>Plots the filter <code>θ</code> using the usual EHT conventions. The default image will use 128x128 pixels with a 120x120 field of view.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/10d52a7caeb9e274223d861a7d2935f528f86435/src/visualizations.jl#LL339-L344">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol,Any},VIDA.Triptic}" href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol,Any},VIDA.Triptic}"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">triptic(image::EHTImage, θ::T) where {T&lt;:AbstractFilter}</code></pre><p>A plot recipe for a triptic plot with the <code>image</code>, i.e. an EHT image and the filter <code>heta</code> used for parameter estimate. The first two panels are the image and filter and the third are RA and DEC cross-sections of both the filter and image centered at the center of light.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/10d52a7caeb9e274223d861a7d2935f528f86435/src/visualizations.jl#LL92-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.bbextract-Union{Tuple{T}, Tuple{Any,T,Any,Any,Vararg{Any,N} where N}} where T&lt;:VIDA.AbstractFilter" href="#VIDA.bbextract-Union{Tuple{T}, Tuple{Any,T,Any,Any,Vararg{Any,N} where N}} where T&lt;:VIDA.AbstractFilter"><code>VIDA.bbextract</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function uses the BlackBoxOptim package to minimize the <code>divergence</code> function. The output from this is then passed to extract to use a deterministic minimizer to find the true minimum.</p><p>Returns a tuple with elements (filter, div_min, converged, iterations)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/10d52a7caeb9e274223d861a7d2935f528f86435/src/extractor.jl#LL62-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.centroid-Tuple{EHTImage}" href="#VIDA.centroid-Tuple{EHTImage}"><code>VIDA.centroid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">centroid(img)
</code></pre><p>Finds the centroid or center of light of the <code>img</code> in μas.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/10d52a7caeb9e274223d861a7d2935f528f86435/src/images.jl#LL174-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.clipimage" href="#VIDA.clipimage"><code>VIDA.clipimage</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">clipimage(clip, im)
clipimage(clip, im, mode)
</code></pre><p>Clips the image <code>im</code> according to the value clip, which can either be an absolute flux in Jy/px or the intensity relative to the maximum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/10d52a7caeb9e274223d861a7d2935f528f86435/src/images.jl#LL48-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.contrastboot-Tuple{Any,EHTImage}" href="#VIDA.contrastboot-Tuple{Any,EHTImage}"><code>VIDA.contrastboot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">contrastboot(β, im)
</code></pre><p>Boosts the constrast of an image by a factor of <code>β</code>.</p><p><strong>Details</strong></p><p>The boosts the contrast of an image according to the formula</p><div>\[ I_\beta(x,y) = \left(\frac{I(x,y)}{I_{max}}\right)^{\beta}.\]</div><p>This should rarely be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/10d52a7caeb9e274223d861a7d2935f528f86435/src/images.jl#LL117-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.downsample-Tuple{Int64,EHTImage}" href="#VIDA.downsample-Tuple{Int64,EHTImage}"><code>VIDA.downsample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">downsample(factor, im)
</code></pre><p>Down samples the image <code>im</code> by a <code>factor</code></p><p><strong>Details</strong></p><p>Given an image <code>im</code> with <span>$Nx\times Ny$</span> pixels, <code>downsample</code> converts that to an image with <span>$Nx/factor \times Ny/factor$</span> pixels. This can be useful when the image has much higher resolutions than is needed for feature extraction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/10d52a7caeb9e274223d861a7d2935f528f86435/src/images.jl#LL71-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.extract-Union{Tuple{T}, Tuple{Any,T,Any,Any,Vararg{Any,N} where N}} where T&lt;:VIDA.AbstractFilter" href="#VIDA.extract-Union{Tuple{T}, Tuple{Any,T,Any,Any,Vararg{Any,N} where N}} where T&lt;:VIDA.AbstractFilter"><code>VIDA.extract</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">extract(divergence, θinit, lbounds, ubounds, args; method, kwargs...)
</code></pre><p>This is the single threaded version of extract. By default we use simulated annealing for the maximization, since other than the BlackBoxOptim drivers it tends to find the global max unlike some of the local methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/10d52a7caeb9e274223d861a7d2935f528f86435/src/extractor.jl#LL89-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.extract-Union{Tuple{T}, Tuple{Int64,Any,T,Any,Any,Vararg{Any,N} where N}} where T&lt;:VIDA.AbstractFilter" href="#VIDA.extract-Union{Tuple{T}, Tuple{Int64,Any,T,Any,Any,Vararg{Any,N} where N}} where T&lt;:VIDA.AbstractFilter"><code>VIDA.extract</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">extract(nstart, divergence, θinit, lbounds, ubounds, args; kwargs...)
</code></pre><p>Function that uses Optim.jl to minimize our divergence to extract the image features. <code>divergence</code>. <code>θinit</code>, is the initial filter to use and must be a subtype of AbstractFilter. <code>lbounds</code> and <code>ubounds</code> are the upper and lower bounds of the problem. <code>method</code> is the maximization algorithm to use. For a list of availible methos see the Optim.jl package, as well as for the other various args, and kwargs that can be passed.</p><p><strong>Notes</strong></p><p><code>lbounds</code> and <code>ubounds</code> will actually be evaluated, namely they must be included in the mode they form the closed hypercube of parameter space.</p><p>This is also the threaded version of the code. If you want to just run a single case don&#39;t pass nstart.</p><p>Also most of the filters aren&#39;t autodiffable right now so be careful with the autodiff feature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/10d52a7caeb9e274223d861a7d2935f528f86435/src/extractor.jl#LL1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.filter_image-Tuple{VIDA.AbstractFilter,Int64,Any,Any}" href="#VIDA.filter_image-Tuple{VIDA.AbstractFilter,Int64,Any,Any}"><code>VIDA.filter_image</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">filter_image(θ, npix, xlim, ylim)
</code></pre><p>Creates an npix×npix rasterized image of the filter <code>θ</code> with limits <code>xlim</code> and <code>ylim</code></p><p>Returns the tuple (xitr,yitr,image) where xitr,yitr are the iterators defining the pixel locations (which are centered) and the rasterized image,  in Jy/μas^2.</p><p><strong>Note</strong></p><p>I use the pixel size definition field<em>of</em>view/npix, but the image is evaluated at the pixel centers.</p><p>We also use the astronomer orientation and ordering.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/10d52a7caeb9e274223d861a7d2935f528f86435/src/filters.jl#LL746-L761">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.flux-Tuple{EHTImage}" href="#VIDA.flux-Tuple{EHTImage}"><code>VIDA.flux</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">flux(img)
</code></pre><p>Finds the image flux of an EHTImage <code>img</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/10d52a7caeb9e274223d861a7d2935f528f86435/src/images.jl#LL242-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.inertia" href="#VIDA.inertia"><code>VIDA.inertia</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">inertia(img)
inertia(img, center)
</code></pre><p>Find the image moment of inertia or <strong>second moment</strong></p><p><strong>Notes</strong></p><p>If <code>center=true</code> then we find the central second moment, or the second cumulant of the image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/10d52a7caeb9e274223d861a7d2935f528f86435/src/images.jl#LL200-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.load_ehtimfits-Tuple{String}" href="#VIDA.load_ehtimfits-Tuple{String}"><code>VIDA.load_ehtimfits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">load_ehtimfits(fits_name)
</code></pre><p>where <code>fits_name</code> should be a fits file generated using ehtim</p><p><strong>Details</strong></p><p>This reads in a fits file created using ehtim. This is because ehtim only outputs the image and not a separate HDU for the field, so the usual fits reader doesn&#39;t work properly.</p><p>The function returns an EHTImage object that contains the relevant image and parameters extracted from the fits file. It also ensures that we are astronomers and that the image using sky-left coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/10d52a7caeb9e274223d861a7d2935f528f86435/src/images.jl#LL141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.unpack-Union{Tuple{T}, Tuple{T}} where T&lt;:VIDA.AbstractFilter" href="#VIDA.unpack-Union{Tuple{T}, Tuple{T}} where T&lt;:VIDA.AbstractFilter"><code>VIDA.unpack</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unpack(θinit)
</code></pre><p>Unpacks the parameters of the filter <code>θ</code></p><p>Returns the parameters in a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/10d52a7caeb9e274223d861a7d2935f528f86435/src/filters.jl#LL599-L605">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.window_image-Tuple{Any,Any,EHTImage}" href="#VIDA.window_image-Tuple{Any,Any,EHTImage}"><code>VIDA.window_image</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">window_image(domain_x, domain_y, im)
</code></pre><p>Given an image <code>im</code> it selects a new field of view for the image given by <code>domain_x</code>, <code>domain_y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/10d52a7caeb9e274223d861a7d2935f528f86435/src/images.jl#LL93-L97">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 16 August 2020 23:53">Sunday 16 August 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
