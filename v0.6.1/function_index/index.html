<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · VIDA.jl</title><link rel="canonical" href="https://ptiede.github.io/VIDA.jl/function_index/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">VIDA.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ptiede/VIDA.jl/blob/master/docs/src/function_index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><ul><li><a href="#VIDA.VIDA"><code>VIDA.VIDA</code></a></li><li><a href="#VIDA.AbstractDivergence"><code>VIDA.AbstractDivergence</code></a></li><li><a href="#VIDA.AbstractFilter"><code>VIDA.AbstractFilter</code></a></li><li><a href="#VIDA.AbstractFitsImage"><code>VIDA.AbstractFitsImage</code></a></li><li><a href="#VIDA.AbstractImage"><code>VIDA.AbstractImage</code></a></li><li><a href="#VIDA.AddFilter"><code>VIDA.AddFilter</code></a></li><li><a href="#VIDA.AsymGaussian"><code>VIDA.AsymGaussian</code></a></li><li><a href="#VIDA.BBO"><code>VIDA.BBO</code></a></li><li><a href="#VIDA.Bhattacharyya"><code>VIDA.Bhattacharyya</code></a></li><li><a href="#VIDA.CMAES"><code>VIDA.CMAES</code></a></li><li><a href="#VIDA.Constant"><code>VIDA.Constant</code></a></li><li><a href="#VIDA.CosineRing-Union{Tuple{AbstractArray}, Tuple{M}, Tuple{N}} where M where N"><code>VIDA.CosineRing</code></a></li><li><a href="#VIDA.CosineRing"><code>VIDA.CosineRing</code></a></li><li><a href="#VIDA.Disk"><code>VIDA.Disk</code></a></li><li><a href="#VIDA.EHTImage"><code>VIDA.EHTImage</code></a></li><li><a href="#VIDA.EllipticalGaussianRing"><code>VIDA.EllipticalGaussianRing</code></a></li><li><a href="#VIDA.ExtractProblem"><code>VIDA.ExtractProblem</code></a></li><li><a href="#VIDA.GaussianRing"><code>VIDA.GaussianRing</code></a></li><li><a href="#VIDA.GeneralGaussianRing"><code>VIDA.GeneralGaussianRing</code></a></li><li><a href="#VIDA.KullbackLeibler"><code>VIDA.KullbackLeibler</code></a></li><li><a href="#VIDA.MulFilter"><code>VIDA.MulFilter</code></a></li><li><a href="#VIDA.Opt"><code>VIDA.Opt</code></a></li><li><a href="#VIDA.Optimizer"><code>VIDA.Optimizer</code></a></li><li><a href="#VIDA.SlashedGaussianRing"><code>VIDA.SlashedGaussianRing</code></a></li><li><a href="#VIDA.TIDAGaussianRing"><code>VIDA.TIDAGaussianRing</code></a></li><li><a href="#Base.split-Tuple{VIDA.AbstractFilter}"><code>Base.split</code></a></li><li><a href="#VIDA.centroid-Tuple{EHTImage}"><code>VIDA.centroid</code></a></li><li><a href="#VIDA.clipimage"><code>VIDA.clipimage</code></a></li><li><a href="#VIDA.downsample-Tuple{Int64,EHTImage}"><code>VIDA.downsample</code></a></li><li><a href="#VIDA.extractor-Tuple{Any,Any}"><code>VIDA.extractor</code></a></li><li><a href="#VIDA.field_of_view-Tuple{EHTImage}"><code>VIDA.field_of_view</code></a></li><li><a href="#VIDA.filter_image-Tuple{VIDA.AbstractFilter,Int64,Any,Any}"><code>VIDA.filter_image</code></a></li><li><a href="#VIDA.flux-Tuple{EHTImage}"><code>VIDA.flux</code></a></li><li><a href="#VIDA.get_radec-Union{Tuple{T}, Tuple{T}} where T&lt;:VIDA.AbstractFitsImage"><code>VIDA.get_radec</code></a></li><li><a href="#VIDA.inertia"><code>VIDA.inertia</code></a></li><li><a href="#VIDA.load_ehtimfits-Tuple{String}"><code>VIDA.load_ehtimfits</code></a></li><li><a href="#VIDA.load_fits-Tuple{String}"><code>VIDA.load_fits</code></a></li><li><a href="#VIDA.rescale_image-Tuple{EHTImage,Any,Any,Any}"><code>VIDA.rescale_image</code></a></li><li><a href="#VIDA.stack-Union{Tuple{T}, Tuple{T,Vararg{Any,N} where N}} where T&lt;:VIDA.AbstractFilter"><code>VIDA.stack</code></a></li><li><a href="#VIDA.threaded_extractor-Union{Tuple{T}, Tuple{S2}, Tuple{S1}, Tuple{Int64,ExtractProblem{S1,S2},T}} where T&lt;:VIDA.Optimizer where S2 where S1"><code>VIDA.threaded_extractor</code></a></li><li><a href="#VIDA.unpack-Union{Tuple{T}, Tuple{T}} where T&lt;:VIDA.AbstractFilter"><code>VIDA.unpack</code></a></li><li><a href="#VIDA.window_image-Tuple{Any,Any,EHTImage}"><code>VIDA.window_image</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="VIDA.VIDA" href="#VIDA.VIDA"><code>VIDA.VIDA</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia">VIDA</code></pre><p>Is a image feature extraction tool for use with EHT images of black holes. It assumes that the image is close to one of the filters we have implemented and then tries to extract that feature from the image using one of the probability divergences implemented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/b4a743b5ce6e24f0e096a89128807dc13eb232ef/src/VIDA.jl#LL2-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.AbstractDivergence" href="#VIDA.AbstractDivergence"><code>VIDA.AbstractDivergence</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractDivergence</code></pre><p>An abstract class for a divergence of a function. This is defined in terms of an Image type object. For two examples see below</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/b4a743b5ce6e24f0e096a89128807dc13eb232ef/src/divergences.jl#LL2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.AbstractFilter" href="#VIDA.AbstractFilter"><code>VIDA.AbstractFilter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractFilter</code></pre><p>An absract type that will contain the filter information, such as the parameters. Specific instanstantiations will need to be defined for you to use this.</p><p><strong>Details</strong></p><pre><code class="language-none">This defined the highest function type. If you wish to implement your own filter you
need to define a a couple of things
1. The filter type &lt;: AbstractFilter
2. an functor of the type that computes the filter function
3. an `size` function that defines the number of parameters of the filter.</code></pre><p>An example is given by:</p><pre><code class="language-julia">#All of our composite type are defined using the Paramters.jl package to you
can directly refer to the struct parameters when creating it, although this isn&#39;t
actually used anywhere in the code.
@with_kw struct Gaussian &lt;: AbstractFilter
    σ::Float64
    x0::Float64
    y0::Float64
end

#Typically we inline and force the function to use fastmath
@fastmath @inline function (θ::Gaussian)(x,y)
    return 1.0/(2π*σ^2)*exp(-0.5*( (x-x0)^2+(y-y0)^2 ) )
end
size(::Type{Gaussian}) = 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/b4a743b5ce6e24f0e096a89128807dc13eb232ef/src/filters.jl#LL3-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.AbstractFitsImage" href="#VIDA.AbstractFitsImage"><code>VIDA.AbstractFitsImage</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An absract image that will hold a fits image after being created or parsed in. This will form the basis for most astronomical images that are defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/b4a743b5ce6e24f0e096a89128807dc13eb232ef/src/images.jl#LL9-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.AbstractImage" href="#VIDA.AbstractImage"><code>VIDA.AbstractImage</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An abstact type that acts as a wrapper for image objects used in astronomy.</p><p>This is the top of the castle for images and will be rarely touched. Basically unless you don&#39;t want to use fits images this will not be used</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/b4a743b5ce6e24f0e096a89128807dc13eb232ef/src/images.jl#LL1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.AddFilter" href="#VIDA.AddFilter"><code>VIDA.AddFilter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct AddFilter{T1&lt;:VIDA.AbstractFilter, T2&lt;:VIDA.AbstractFilter} &lt;: VIDA.AbstractFilter</code></pre><p>Combines two filters together into one object. Since addition is assoiciative this can actually we used to hold multiple different filters.</p><p><strong>Details</strong></p><p>Overloads the Base.:+ function so you can easily add two filters together.</p><p><strong>Example</strong></p><pre><code class="language-julia">θ1 = GaussianRing(10,5,0,0)
θ2 = SlashedGaussianRing(15,5,0.5,π/4,0,0)
θ12 = θ1+θ2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/b4a743b5ce6e24f0e096a89128807dc13eb232ef/src/filters.jl#LL632-L646">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.AsymGaussian" href="#VIDA.AsymGaussian"><code>VIDA.AsymGaussian</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct AsymGaussian &lt;: VIDA.AbstractFilter</code></pre><p>An asymmetric Gaussian blob.</p><p><strong>Details</strong></p><p>Defines a asymmetric Gaussian image. This is useful if the image has some non-ring emission in the and you need to soak up some of the flux.</p><p>The parameters of the model follow very closely to those used in Themis. The Gaussian size <code>σ</code> is given by     σ = √(σxσy)     τ = 1-σy/σx, where σx,σy are the semi-major,minor axis lenght respectively. This is similar to how the asymmetry for the <code>EllipticalGaussianRing</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>σ</code></p><p>Gaussian size in μas</p></li><li><p><code>τ</code></p><p>Gaussian asymmetry</p></li><li><p><code>ξ</code></p><p>Gaussian orientation in radians measured north of east</p></li><li><p><code>x0</code></p><p>x position of Gaussian center in μas</p></li><li><p><code>y0</code></p><p>y position of Gaussian center in μas</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.BBO" href="#VIDA.BBO"><code>VIDA.BBO</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct BBO &lt;: VIDA.Optimizer</code></pre><p>Defines the interface for the BlackBoxOptim interface. This requires that the user to have imported the BlackBoxOptim package.</p><p><strong>Fields</strong></p><ul><li>popsize: The population size DEFAULT 64</li><li>maxevals: The maximum number of times to evaluate the divergence before terminiation.</li><li>tracemode: The output option. Default is silent, i.e. no output.</li></ul><p>Other options are <code>:compact</code> and <code>:verbose</code></p><p><strong>Notes</strong></p><p>This uses the default BlackBoxOptim optimizer i.e. adaptive<em>de</em>rand<em>1</em>bin_radiuslimited. Currently other options aren&#39;t implemented since I found that this version tended to work the best.</p><p><strong>Fields</strong></p><ul><li><p><code>method</code></p><p>Default: :adaptive<em>de</em>rand<em>1</em>bin_radiuslimited</p></li><li><p><code>popsize</code></p><p>Default: 64</p></li><li><p><code>maxevals</code></p><p>Default: 25000</p></li><li><p><code>tracemode</code></p><p>Default: :compact</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.Bhattacharyya" href="#VIDA.Bhattacharyya"><code>VIDA.Bhattacharyya</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Bhattacharyya{T, S} &lt;: VIDA.AbstractDivergence</code></pre><p>Type for the Bhattacharyya divergence. It constructed from an <code>EHTImage</code> i.e. data. Additionally to evaluate the divergence we use a functor approach where if θ is your</p><p><strong>Details</strong></p><p>This computes the Bhattacharyya divergence which is related to Hellinger distance between two distributions. In fact, they are both minimized at the same point. The Bhattacharyya divergence is defined as</p><div>\[Bh(f_\theta||\hat{I}) = -\log\int \sqrt{f_\theta(x,y)\hat{I}(x,y)}dxdy,\]</div><p>where <span>$\hat{I}$</span> is defined as the image normalized to unit flux.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/b4a743b5ce6e24f0e096a89128807dc13eb232ef/src/divergences.jl#LL9-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.CMAES" href="#VIDA.CMAES"><code>VIDA.CMAES</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct CMAES &lt;: VIDA.Optimizer</code></pre><p>Defines the interface for the LBFGS-B interface from the Optim.jl package. This requires that the user to have imported the <strong>CMAEvolutionStrategy package</strong>.</p><p>Typically I have found that this works very well. This the usual first optimizer to try.</p><p><strong>Fields</strong></p><ul><li><p><code>popsize</code></p><p>PopulationSize  Default: 64</p></li><li><p><code>cov_scale</code></p><p>Initial covariance scale  Default: 1.0</p></li><li><p><code>ftarget</code></p><p>target divergence values. <code>nothing</code> means there is no target  Default: nothing</p></li><li><p><code>xtol</code></p><p>xtol Default: nothing</p></li><li><p><code>ftol</code></p><p>ftol Default: 1.0e-11</p></li><li><p><code>maxevals</code></p><p>maximum number of divergence evals, nothing means run until termination Default: nothing</p></li><li><p><code>verbosity</code></p><p>verbosity of output Default: 1</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.Constant" href="#VIDA.Constant"><code>VIDA.Constant</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Constant &lt;: VIDA.AbstractFilter</code></pre><p>An constant filter.</p><p><strong>Details</strong></p><p>Defines an image that just has constant flux. This is very useful for soaking up low levels of flux in image reconstructions that can bias the results.</p><p>Since images or normalized to unity, this means the <code>Constant</code> filter has no additional parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/b4a743b5ce6e24f0e096a89128807dc13eb232ef/src/filters.jl#LL37-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.CosineRing" href="#VIDA.CosineRing"><code>VIDA.CosineRing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct CosineRing{N, M} &lt;: VIDA.AbstractFilter</code></pre><p>Extrememly flexible ring model. The thickness is modeled as a cosine expansion with <code>N</code> terms and the slash by a expansion with <code>M</code> terms.</p><p><strong>Details</strong></p><p>The ring is allowed to be elliptical. The thickness of the ring is modeled by a cosine expansion in azimuthal angle. <code>N</code> specifies the number of cosine modes to fit, where the first mode is the constant thickness portion and so has no corresponding angle. The slash is modeled as a separate cosine expansion, with <code>M</code> terms. Here the zero order term is forced to be unity, so <code>M</code> defines the <code>M</code> additional terms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.CosineRing-Union{Tuple{AbstractArray}, Tuple{M}, Tuple{N}} where M where N" href="#VIDA.CosineRing-Union{Tuple{AbstractArray}, Tuple{M}, Tuple{N}} where M where N"><code>VIDA.CosineRing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CosineRing{N,M}(p::AbstractArray) where {N,M}</code></pre><p>Takes in a vector of paramters describing the filter.</p><p><strong>Details</strong></p><p>The order of the vector must be</p><ul><li>p[1] = <code>r0</code></li><li>p[2:(N+1)] = <code>σ</code></li><li>p[(N+2):(2N)] = <code>ξσ</code></li><li>p[2N+1] = <code>τ</code></li><li>p[2N+2] = <code>ξτ</code></li><li>p[2N+3:2N+M+2] = <code>s</code></li><li>p[2N+3+M:2N+2+2M] = <code>ξs</code></li><li>p[2N+3+2M] = <code>x0</code></li><li>p[2N+4+2M] = <code>y0</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/b4a743b5ce6e24f0e096a89128807dc13eb232ef/src/filters.jl#LL482-L496">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.Disk" href="#VIDA.Disk"><code>VIDA.Disk</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Disk &lt;: VIDA.AbstractFilter</code></pre><p>A smoothed disk model</p><p><strong>Details</strong></p><p>Defines a filter for an image that has a smoothed disk model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.EHTImage" href="#VIDA.EHTImage"><code>VIDA.EHTImage</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct EHTImage{T} &lt;: VIDA.AbstractFitsImage{T}</code></pre><p><strong>Details</strong></p><p>The trait is to hold a EHT image tyically in matrix form. Namely the trait will typically be Matrix{Float64}.</p><p><code>nx</code> is the number of pixels in the x or RA direction <code>ny</code> is the number of pixels in the y or DEC direction <code>psize_x</code>, <code>psize_y</code> are the pixel sizes in the x and y direction <code>source</code> is the source we are looking at e.g. M87 <code>ra</code>,<code>dec</code> are the sources RA and DEC in J2000 coordinates using degrees <code>wavelength</code> is the wavelength of the image. <code>mjd</code> is the Modified Julian Date of the observation. <code>img</code> is the actual pixeled image in Jy/pixel</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/b4a743b5ce6e24f0e096a89128807dc13eb232ef/src/images.jl#LL15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.EllipticalGaussianRing" href="#VIDA.EllipticalGaussianRing"><code>VIDA.EllipticalGaussianRing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct EllipticalGaussianRing &lt;: VIDA.AbstractFilter</code></pre><p>Implements the elliptical gaussian ring filter. Where the ellipticity <code>tau</code> is defined as one minus ratio between the semi-minor and semi-major axis.</p><p><strong>Details</strong></p><p>Adds ellipticity to the ring. The radius <code>r0</code> of the ring is now defined as the geometric mean of the semi-major (a) and semi-minor (b) axis lengths i.e.</p><p>r0 = √(a*b).</p><p>The ellipticity <code>τ</code> is given by τ = 1-b/a.</p><p><strong>Fields</strong></p><ul><li><p><code>r0</code></p><p>Radius of the Gaussian ring</p></li><li><p><code>σ</code></p><p>Standard deviation of the width of the Gaussian ring</p></li><li><p><code>τ</code></p><p>Asymmetry of the Gaussian ring defined as <span>$1-b/a$</span></p></li><li><p><code>ξ</code></p><p>Asymmetry orientation in radians measured north of east</p></li><li><p><code>x0</code></p><p>x position of the center of the ring in μas</p></li><li><p><code>y0</code></p><p>y position of the center of the ring in μas</p></li></ul><p><strong>Notes</strong></p><p>There is no normalization since the ellipticity makes it impossible to normalize analytically. In fact the distance from the ellipse is implemented numerically using an algorithm adapted from <a href="https://github.com/0xfaded/ellipse_demo/issues/1#issuecomment-405078823">git</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.ExtractProblem" href="#VIDA.ExtractProblem"><code>VIDA.ExtractProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ExtractProblem{T&lt;:AbstractDivergence, S&lt;:AbstractFilter}</code></pre><p>Defines a feature extraction problem to minimize, with an abstract filte and an abstract divergence. This is needed to interface with the extractor minimizer, which will minimize the divergence to find the optimal filter.</p><p><strong>Fields</strong></p><ul><li><p><code>div</code></p><p>Divergence function to minimize</p></li><li><p><code>θinit</code></p><p>Initial location of the optimizer</p></li><li><p><code>θlower</code></p><p>Lower bound of the search region</p></li><li><p><code>θupper</code></p><p>Upper bound of the search region</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/b4a743b5ce6e24f0e096a89128807dc13eb232ef/src/extractor.jl#LL82-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.GaussianRing" href="#VIDA.GaussianRing"><code>VIDA.GaussianRing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct GaussianRing &lt;: VIDA.AbstractFilter</code></pre><p>Symmetric gaussian ring filter. This is the most basic filter and just attempts to recover a location <code>x0</code>,<code>y0</code>, radius <code>r0</code> and thickness <code>σ</code> from some image.</p><p><strong>Fields</strong></p><ul><li><p><code>r0</code></p><p>Radius of Gaussian ring in μas</p></li><li><p><code>σ</code></p><p>Standard deviation of Gaussian ring in μas</p></li><li><p><code>x0</code></p><p>x location of the center of the Gaussian ring in μas</p></li><li><p><code>y0</code></p><p>y location of the center of the Gaussian ring in μas</p></li></ul><p><strong>Example</strong></p><pre><code class="language-julia">GaussianRing(r0=20.0,σ=5.0,x0=0.0,y0=-10.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.GeneralGaussianRing" href="#VIDA.GeneralGaussianRing"><code>VIDA.GeneralGaussianRing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct GeneralGaussianRing &lt;: VIDA.AbstractFilter</code></pre><p>Creates the most general elliptical slashed gaussian ring model. It is a combination of the elliptical and slashed gaussian ring. The direction of the slash and the ellipticity are not aligned or anti-aligned like with the TIDAGaussianRing type.</p><p><strong>Details</strong></p><p>Adds ellipticity to the ring. The radius <code>r0</code> of the ring is now defined as the geometric mean of the semi-major (a) and semi-minor (b) axis lengths i.e.</p><p>r0 = √(a*b).</p><p>The ellipticity <code>τ</code> is given by τ = 1-b/a.</p><p><strong>Fields</strong></p><ul><li><p><code>r0</code></p><p>Radius of the Gaussian ring</p></li><li><p><code>σ</code></p><p>Standard deviation of the width of the Gaussian ring</p></li><li><p><code>τ</code></p><p>Asymmetry of the Gaussian ring defined as <span>$1-b/a$</span></p></li><li><p><code>ξτ</code></p><p>Asymmetry orientation in radians, measured north of east</p></li><li><p><code>s</code></p><p>Slash of Gaussian ring.</p></li><li><p><code>ξs</code></p><p>Slash orientation in radians measured north of east</p></li><li><p><code>x0</code></p><p>x position of the center of the ring in μas</p></li><li><p><code>y0</code></p><p>y position of the center of the ring in μas</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.KullbackLeibler" href="#VIDA.KullbackLeibler"><code>VIDA.KullbackLeibler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct KullbackLeibler{T, S} &lt;: VIDA.AbstractDivergence</code></pre><p>Type for the KL divergence. It constructed from an <code>EHTImage</code> i.e. data. Additionally to evaluate the divergence we use a functor approach where if θ is your</p><p><strong>Details</strong></p><p>This computes the KL divergence which is related to Hellinger distance between two distributions. In fact, they are both minimized at the same point. The Bhattacharyya divergence is defined as</p><div>\[KL(f_\theta||\hat{I}) = -\log\int f_{\theta}(x,y)\log
        \left(\frac{f_{\theta}(x,y)}{\hat{I}(x,y)}\rightdxdy,\]</div><p>where <span>$\hat{I}$</span> is defined as the image normalized to unit flux.</p><p>This struct is also a functor. ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/b4a743b5ce6e24f0e096a89128807dc13eb232ef/src/divergences.jl#LL58-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.MulFilter" href="#VIDA.MulFilter"><code>VIDA.MulFilter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct MulFilter{T&lt;:VIDA.AbstractFilter, S&lt;:Number} &lt;: VIDA.AbstractFilter</code></pre><p>Multiplies filter by a constant. This is useful when combining with AddFilter since it will change the relative weights of each filter.</p><p><strong>Details</strong></p><p>Overloads the Base.:* function so you can easily multiple a filter by a number.</p><p><strong>Example</strong></p><pre><code class="language-julia">θ = GaussianRing(15,5,0.0,0.0)
2*θ</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/b4a743b5ce6e24f0e096a89128807dc13eb232ef/src/filters.jl#LL680-L693">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.Opt" href="#VIDA.Opt"><code>VIDA.Opt</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Opt{O&lt;:Optim.AbstractConstrainedOptimizer} &lt;: VIDA.Optimizer</code></pre><p>Defines the interface for the LBFGS-B interface from the Optim.jl package. This requires that the user to have imported the <strong>Optim package</strong>.</p><p><strong>Fields</strong></p><ul><li><p><code>opt</code></p></li><li><p><code>options</code></p><p>Default: Optim.Options()</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.Optimizer" href="#VIDA.Optimizer"><code>VIDA.Optimizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type Optimizer</code></pre><p>Abstract optimizer class that defines the optimizer to use. This is the interface I&#39;ll need to define all the different optimizer classes below.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/b4a743b5ce6e24f0e096a89128807dc13eb232ef/src/extractor.jl#LL1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.SlashedGaussianRing" href="#VIDA.SlashedGaussianRing"><code>VIDA.SlashedGaussianRing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct SlashedGaussianRing &lt;: VIDA.AbstractFilter</code></pre><p>Implements the slashed gaussian ring filter, that uses a cosine to symmetrically implement the slash. While this is marginally more complicated that a linear slash, it has a number of benefits such as mainting the azimuthal and smooth structure of the image.</p><p><strong>Fields</strong></p><ul><li><p><code>r0</code></p><p>Radius of the ring in μas</p></li><li><p><code>σ</code></p><p>Standard deviation of Gaussian ring in μas</p></li><li><p><code>s</code></p><p>Slash strength of Gaussiang ring. 0 means no slash</p></li><li><p><code>ξ</code></p><p>Rotation angle in radians of slash direction, measured north of west</p></li><li><p><code>x0</code></p><p>x position of the center of the ring in μas</p></li><li><p><code>y0</code></p><p>y position of the center of the ring in μas</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.TIDAGaussianRing" href="#VIDA.TIDAGaussianRing"><code>VIDA.TIDAGaussianRing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct TIDAGaussianRing &lt;: VIDA.AbstractFilter</code></pre><p>Creates the filter from the Paper I am writing. It is a combination of the elliptical and slashed gaussian ring. The slash and the semi-major axis are either aligned if the slash parameter <code>s</code>&gt;0 or antialigned if <code>s</code>&lt;0.</p><p><strong>Details</strong></p><p>Adds ellipticity to the ring. The radius <code>r0</code> of the ring is now defined as the geometric mean of the semi-major (a) and semi-minor (b) axis lengths i.e.</p><p>r0 = √(a*b).</p><p>The ellipticity <code>τ</code> is given by τ = 1-b/a.</p><p><strong>Fields</strong></p><ul><li><p><code>r0</code></p><p>Radius of the Gaussian ring</p></li><li><p><code>σ</code></p><p>Standard deviation of the width of the Gaussian ring</p></li><li><p><code>τ</code></p><p>Asymmetry of the Gaussian ring defined as <span>$1-b/a$</span></p></li><li><p><code>s</code></p><p>Slash of Gaussian ring.</p></li><li><p><code>ξ</code></p><p>Slash/Asymmetry orientation in radians measured north of east</p></li><li><p><code>x0</code></p><p>x position of the center of the ring in μas</p></li><li><p><code>y0</code></p><p>y position of the center of the ring in μas</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/44fa15b1502a45eac76c9017af94332d4557b251/base/#L0-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.split-Tuple{VIDA.AbstractFilter}" href="#Base.split-Tuple{VIDA.AbstractFilter}"><code>Base.split</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">split(θ)
</code></pre><p>Splits the filter into an array with its subcomponents so you can easily access them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/b4a743b5ce6e24f0e096a89128807dc13eb232ef/src/filters.jl#LL749-L752">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.centroid-Tuple{EHTImage}" href="#VIDA.centroid-Tuple{EHTImage}"><code>VIDA.centroid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">centroid(img)
</code></pre><p>Finds the centroid or center of light of the <code>img</code> in μas.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/b4a743b5ce6e24f0e096a89128807dc13eb232ef/src/images.jl#LL250-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.clipimage" href="#VIDA.clipimage"><code>VIDA.clipimage</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">clipimage(clip, im)
clipimage(clip, im, mode)
</code></pre><p>Clips the image <code>im</code> according to the value clip, which can either be an absolute flux in Jy/px or the intensity relative to the maximum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/b4a743b5ce6e24f0e096a89128807dc13eb232ef/src/images.jl#LL66-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.downsample-Tuple{Int64,EHTImage}" href="#VIDA.downsample-Tuple{Int64,EHTImage}"><code>VIDA.downsample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">downsample(factor, im)
</code></pre><p>Down samples the image <code>im</code> by a <code>factor</code></p><p><strong>Details</strong></p><p>Given an image <code>im</code> with <span>$Nx\times Ny$</span> pixels, <code>downsample</code> converts that to an image with <span>$Nx/factor \times Ny/factor$</span> pixels. This can be useful when the image has much higher resolutions than is needed for feature extraction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/b4a743b5ce6e24f0e096a89128807dc13eb232ef/src/images.jl#LL89-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.extractor-Tuple{Any,Any}" href="#VIDA.extractor-Tuple{Any,Any}"><code>VIDA.extractor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">extractor(prob::ExtractProblem, optimizer::Optimizer)</code></pre><p>This extracts the optimal filter defined by the <code>prob</code> problem. This will minimize the divergence in prob and return the optimal filter and minimum divergence in a tuple.</p><p><code>optimizer</code> is one of VIDA&#39;s optimizer types. Typically I would recommend the BBO() optimizer</p><p><strong>Examples</strong></p><pre><code class="language-julia">    θopt, divmin = extractor(prob, BBO())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/b4a743b5ce6e24f0e096a89128807dc13eb232ef/src/extractor.jl#LL129-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.field_of_view-Tuple{EHTImage}" href="#VIDA.field_of_view-Tuple{EHTImage}"><code>VIDA.field_of_view</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">field_of_view(img::EHTImage)</code></pre><p>Finds the field of view of an EHTImage. Return a w element tuple with the field of view in the x and y direction</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/b4a743b5ce6e24f0e096a89128807dc13eb232ef/src/images.jl#LL355-L359">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.filter_image-Tuple{VIDA.AbstractFilter,Int64,Any,Any}" href="#VIDA.filter_image-Tuple{VIDA.AbstractFilter,Int64,Any,Any}"><code>VIDA.filter_image</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">filter_image(θ, npix, xlim, ylim)
</code></pre><p>Creates an npix×npix rasterized image of the filter <code>θ</code> with limits <code>xlim</code> and <code>ylim</code></p><p>Returns the tuple (xitr,yitr,image) where xitr,yitr are the iterators defining the pixel locations (which are centered) and the rasterized image,  in Jy/μas^2.</p><p><strong>Note</strong></p><p>I use the pixel size definition field<em>of</em>view/npix, but the image is evaluated at the pixel centers.</p><p>We also use the astronomer orientation and ordering.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/b4a743b5ce6e24f0e096a89128807dc13eb232ef/src/filters.jl#LL762-L777">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.flux-Tuple{EHTImage}" href="#VIDA.flux-Tuple{EHTImage}"><code>VIDA.flux</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">flux(img)
</code></pre><p>Finds the image flux of an EHTImage <code>img</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/b4a743b5ce6e24f0e096a89128807dc13eb232ef/src/images.jl#LL318-L321">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.get_radec-Union{Tuple{T}, Tuple{T}} where T&lt;:VIDA.AbstractFitsImage" href="#VIDA.get_radec-Union{Tuple{T}, Tuple{T}} where T&lt;:VIDA.AbstractFitsImage"><code>VIDA.get_radec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_radec(img::T) &lt;: AbstractFitsImage</code></pre><p>Returns two iterators (ra,dec) that give the locations of the <code>img</code> pixels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/b4a743b5ce6e24f0e096a89128807dc13eb232ef/src/images.jl#LL46-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.inertia" href="#VIDA.inertia"><code>VIDA.inertia</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">inertia(img)
inertia(img, center)
</code></pre><p>Find the image moment of inertia or <strong>second moment</strong></p><p><strong>Notes</strong></p><p>If <code>center=true</code> then we find the central second moment, or the second cumulant of the image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/b4a743b5ce6e24f0e096a89128807dc13eb232ef/src/images.jl#LL276-L283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.load_ehtimfits-Tuple{String}" href="#VIDA.load_ehtimfits-Tuple{String}"><code>VIDA.load_ehtimfits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">load_ehtimfits(fits_name)
</code></pre><p>where <code>fits_name</code> should be a fits file generated using ehtim</p><p><strong>Details</strong></p><p>This reads in a fits file created using ehtim. This is because ehtim only outputs the image and not a separate HDU for the field, so the usual fits reader doesn&#39;t work properly.</p><p>The function returns an EHTImage object that contains the relevant image and parameters extracted from the fits file. It also ensures that we are astronomers and that the image using sky-left coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/b4a743b5ce6e24f0e096a89128807dc13eb232ef/src/images.jl#LL138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.load_fits-Tuple{String}" href="#VIDA.load_fits-Tuple{String}"><code>VIDA.load_fits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">load_fits(fits_name)
</code></pre><p>where <code>fits_name</code> should be a fits file generated using ehtim</p><p><strong>Details</strong></p><p>This reads in a fits file that is more robust to the various imaging algorithms in the EHT, i.e. is works with clean, smili, eht-imaging.</p><p>The function returns an EHTImage object that contains the relevant image and parameters extracted from the fits file. It also ensures that we are astronomers and that the image using sky-left coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/b4a743b5ce6e24f0e096a89128807dc13eb232ef/src/images.jl#LL171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.rescale_image-Tuple{EHTImage,Any,Any,Any}" href="#VIDA.rescale_image-Tuple{EHTImage,Any,Any,Any}"><code>VIDA.rescale_image</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rescale_image(img::EHTImage, npix, xlim, ylim)</code></pre><p><strong>Inputs</strong></p><ul><li>img::EHTImage : Image you want to rescale</li><li>npix : Number of pixels in x and y direction</li><li>xlim : Tuple with the limits of the image in the RA</li><li>ylim : Tuple with the limits of the image in DEC</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/b4a743b5ce6e24f0e096a89128807dc13eb232ef/src/images.jl#LL326-L333">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.stack-Union{Tuple{T}, Tuple{T,Vararg{Any,N} where N}} where T&lt;:VIDA.AbstractFilter" href="#VIDA.stack-Union{Tuple{T}, Tuple{T,Vararg{Any,N} where N}} where T&lt;:VIDA.AbstractFilter"><code>VIDA.stack</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">stack(θ, θ1)
</code></pre><p>Stacks filters together so you can easily combine multiple filters. It does this by calling the :+ and :* method. Every filter added will include an additional parameter that controls the relative weight of each filter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/b4a743b5ce6e24f0e096a89128807dc13eb232ef/src/filters.jl#LL739-L744">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.threaded_extractor-Union{Tuple{T}, Tuple{S2}, Tuple{S1}, Tuple{Int64,ExtractProblem{S1,S2},T}} where T&lt;:VIDA.Optimizer where S2 where S1" href="#VIDA.threaded_extractor-Union{Tuple{T}, Tuple{S2}, Tuple{S1}, Tuple{Int64,ExtractProblem{S1,S2},T}} where T&lt;:VIDA.Optimizer where S2 where S1"><code>VIDA.threaded_extractor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">threaded_extractor(nstart::Int, prob::ExtractProblem, optimizer::Optimizer)</code></pre><p>A threaded multi-start version of the extractor method. This will run <code>nstart</code> instances of extractor, where the initial location of chosen uniformly within the bounds defined in <code>prob</code>.</p><p><strong>Outputs</strong></p><p>This outputs the best filter and minimum divergence of all the extractors run.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/b4a743b5ce6e24f0e096a89128807dc13eb232ef/src/extractor.jl#LL102-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.unpack-Union{Tuple{T}, Tuple{T}} where T&lt;:VIDA.AbstractFilter" href="#VIDA.unpack-Union{Tuple{T}, Tuple{T}} where T&lt;:VIDA.AbstractFilter"><code>VIDA.unpack</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unpack(θinit)
</code></pre><p>Unpacks the parameters of the filter <code>θ</code></p><p>Returns the parameters in a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/b4a743b5ce6e24f0e096a89128807dc13eb232ef/src/filters.jl#LL596-L602">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.window_image-Tuple{Any,Any,EHTImage}" href="#VIDA.window_image-Tuple{Any,Any,EHTImage}"><code>VIDA.window_image</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">window_image(domain_x, domain_y, im)
</code></pre><p>Given an image <code>im</code> it selects a new field of view for the image given by <code>domain_x</code>, <code>domain_y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/b4a743b5ce6e24f0e096a89128807dc13eb232ef/src/images.jl#LL111-L115">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 18 November 2020 01:16">Wednesday 18 November 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
