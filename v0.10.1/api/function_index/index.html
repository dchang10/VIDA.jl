<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · VIDA.jl</title><link rel="canonical" href="https://ptiede.github.io/VIDA.jl/api/function_index/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">VIDA.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../../interface/">Interface</a></li><li><a class="tocitem" href="../../generated/introduction/">Introduction to VIDA</a></li><li><a class="tocitem" href="../../generated/custom_template/">Adding a Custom Template</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Templates"><span>Templates</span></a></li><li><a class="tocitem" href="#Images"><span>Images</span></a></li><li><a class="tocitem" href="#Movies"><span>Movies</span></a></li><li><a class="tocitem" href="#Divergences"><span>Divergences</span></a></li><li><a class="tocitem" href="#Extractor"><span>Extractor</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li><li><a class="tocitem" href="#Visualizations"><span>Visualizations</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ptiede/VIDA.jl/blob/master/docs/src/api/function_index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#API">API</a></li><ul><li><a href="#Contents">Contents</a></li><li><a href="#Index">Index</a></li><li><a href="#Templates">Templates</a></li><li><a href="#Images">Images</a></li><li><a href="#Movies">Movies</a></li><li><a href="#Divergences">Divergences</a></li><li><a href="#Extractor">Extractor</a></li><li><a href="#Utilities">Utilities</a></li><li><a href="#Visualizations">Visualizations</a></li></ul></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#VIDA.AbstractCompositeTemplate"><code>VIDA.AbstractCompositeTemplate</code></a></li><li><a href="#VIDA.AbstractDivergence"><code>VIDA.AbstractDivergence</code></a></li><li><a href="#VIDA.AbstractFitsImage"><code>VIDA.AbstractFitsImage</code></a></li><li><a href="#VIDA.AbstractImage"><code>VIDA.AbstractImage</code></a></li><li><a href="#VIDA.AbstractImageTemplate"><code>VIDA.AbstractImageTemplate</code></a></li><li><a href="#VIDA.AbstractModifierTemplate"><code>VIDA.AbstractModifierTemplate</code></a></li><li><a href="#VIDA.AbstractMovie"><code>VIDA.AbstractMovie</code></a></li><li><a href="#VIDA.AbstractTemplate"><code>VIDA.AbstractTemplate</code></a></li><li><a href="#VIDA.AddTemplate"><code>VIDA.AddTemplate</code></a></li><li><a href="#VIDA.AsymGaussian"><code>VIDA.AsymGaussian</code></a></li><li><a href="#VIDA.BBO"><code>VIDA.BBO</code></a></li><li><a href="#VIDA.Bhattacharyya"><code>VIDA.Bhattacharyya</code></a></li><li><a href="#VIDA.CMAES"><code>VIDA.CMAES</code></a></li><li><a href="#VIDA.Constant"><code>VIDA.Constant</code></a></li><li><a href="#VIDA.CosineRing"><code>VIDA.CosineRing</code></a></li><li><a href="#VIDA.Disk"><code>VIDA.Disk</code></a></li><li><a href="#VIDA.EHTImage"><code>VIDA.EHTImage</code></a></li><li><a href="#VIDA.EHTMovie"><code>VIDA.EHTMovie</code></a></li><li><a href="#VIDA.EllipticalGaussianRing"><code>VIDA.EllipticalGaussianRing</code></a></li><li><a href="#VIDA.ExtractProblem"><code>VIDA.ExtractProblem</code></a></li><li><a href="#VIDA.GaussianRing"><code>VIDA.GaussianRing</code></a></li><li><a href="#VIDA.GeneralGaussianRing"><code>VIDA.GeneralGaussianRing</code></a></li><li><a href="#VIDA.ImageTemplate"><code>VIDA.ImageTemplate</code></a></li><li><a href="#VIDA.KullbackLeibler"><code>VIDA.KullbackLeibler</code></a></li><li><a href="#VIDA.LogSpiral"><code>VIDA.LogSpiral</code></a></li><li><a href="#VIDA.MulTemplate"><code>VIDA.MulTemplate</code></a></li><li><a href="#VIDA.Opt"><code>VIDA.Opt</code></a></li><li><a href="#VIDA.Optimizer"><code>VIDA.Optimizer</code></a></li><li><a href="#VIDA.RotateMod"><code>VIDA.RotateMod</code></a></li><li><a href="#VIDA.SlashedGaussianRing"><code>VIDA.SlashedGaussianRing</code></a></li><li><a href="#VIDA.StretchMod"><code>VIDA.StretchMod</code></a></li><li><a href="#VIDA.SymCosineRing"><code>VIDA.SymCosineRing</code></a></li><li><a href="#VIDA.TIDAGaussianRing"><code>VIDA.TIDAGaussianRing</code></a></li><li><a href="#Base.size-Tuple{T} where T&lt;:VIDA.AbstractTemplate"><code>Base.size</code></a></li><li><a href="#Base.split"><code>Base.split</code></a></li><li><a href="#VIDA.blur-Tuple{EHTImage, Any}"><code>VIDA.blur</code></a></li><li><a href="#VIDA.blur-Tuple{EHTMovie, Any}"><code>VIDA.blur</code></a></li><li><a href="#VIDA.centroid"><code>VIDA.centroid</code></a></li><li><a href="#VIDA.clipimage"><code>VIDA.clipimage</code></a></li><li><a href="#VIDA.extractor"><code>VIDA.extractor</code></a></li><li><a href="#VIDA.field_of_view"><code>VIDA.field_of_view</code></a></li><li><a href="#VIDA.flux-Tuple{EHTMovie, Any}"><code>VIDA.flux</code></a></li><li><a href="#VIDA.flux-Tuple{EHTImage}"><code>VIDA.flux</code></a></li><li><a href="#VIDA.get_frames"><code>VIDA.get_frames</code></a></li><li><a href="#VIDA.get_image"><code>VIDA.get_image</code></a></li><li><a href="#VIDA.get_times"><code>VIDA.get_times</code></a></li><li><a href="#VIDA.inertia"><code>VIDA.inertia</code></a></li><li><a href="#VIDA.join_frames"><code>VIDA.join_frames</code></a></li><li><a href="#VIDA.load_fits"><code>VIDA.load_fits</code></a></li><li><a href="#VIDA.load_hdf5"><code>VIDA.load_hdf5</code></a></li><li><a href="#VIDA.make_image"><code>VIDA.make_image</code></a></li><li><a href="#VIDA.pixelloc"><code>VIDA.pixelloc</code></a></li><li><a href="#VIDA.rescale-Tuple{EHTImage, Any, Any, Any}"><code>VIDA.rescale</code></a></li><li><a href="#VIDA.rescale-Tuple{EHTMovie, Any, Any, Any}"><code>VIDA.rescale</code></a></li><li><a href="#VIDA.rotate"><code>VIDA.rotate</code></a></li><li><a href="#VIDA.save_fits"><code>VIDA.save_fits</code></a></li><li><a href="#VIDA.save_hdf5"><code>VIDA.save_hdf5</code></a></li><li><a href="#VIDA.stack"><code>VIDA.stack</code></a></li><li><a href="#VIDA.stretch"><code>VIDA.stretch</code></a></li><li><a href="#VIDA.stretchrotate"><code>VIDA.stretchrotate</code></a></li><li><a href="#VIDA.template_image"><code>VIDA.template_image</code></a></li><li><a href="#VIDA.threaded_extractor"><code>VIDA.threaded_extractor</code></a></li><li><a href="#VIDA.triptic"><code>VIDA.triptic</code></a></li><li><a href="#VIDA.unpack"><code>VIDA.unpack</code></a></li></ul><h2 id="Templates"><a class="docs-heading-anchor" href="#Templates">Templates</a><a id="Templates-1"></a><a class="docs-heading-anchor-permalink" href="#Templates" title="Permalink"></a></h2><p>These are the various template types and helper functions.</p><article class="docstring"><header><a class="docstring-binding" id="VIDA.AbstractTemplate" href="#VIDA.AbstractTemplate"><code>VIDA.AbstractTemplate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractTemplate</code></pre><p>An abstract type that defines super template type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/templates/templates.jl#LL4-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.AbstractImageTemplate" href="#VIDA.AbstractImageTemplate"><code>VIDA.AbstractImageTemplate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractImageTemplate &lt;: VIDA.AbstractTemplate</code></pre><p>An abstract type that will contain the template information, such as the parameters. Specific instanstantiations will need to be defined for you to use this.</p><p><strong>Details</strong></p><pre><code class="language-none">This defined the highest function type. If you wish to implement your own template you
need to define a a couple of things
1. The template type &lt;: AbstractTemplate
2. an functor of the type that computes the template function
3. an `Base.size` function that defines the number of parameters of the template.</code></pre><p>An example is given by:</p><pre><code class="language-julia">#All of our composite type are defined using the Paramters.jl package to you
can directly refer to the struct parameters when creating it, although this isn&#39;t
actually used anywhere in the code.
@with_kw struct Gaussian &lt;: AbstractImageTemplate
    σ::Float64
    x0::Float64
    y0::Float64
end

#Typically we inline and force the function to use fastmath
 @inline function (θ::Gaussian)(x,y)
    return 1.0/(2π*σ^2)*exp(-0.5*( (x-x0)^2+(y-y0)^2 ) )
end
Base.size(::Type{Gaussian}) = 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/templates/templates.jl#LL26-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.AbstractModifierTemplate" href="#VIDA.AbstractModifierTemplate"><code>VIDA.AbstractModifierTemplate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractModifierTemplate &lt;: VIDA.AbstractTemplate</code></pre><p>Meta-template that accepts a abstract template and modifies it through some analytic transformation. This is useful for model composability.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/templates/templates.jl#LL60-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.AbstractCompositeTemplate" href="#VIDA.AbstractCompositeTemplate"><code>VIDA.AbstractCompositeTemplate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractCompositeTemplate &lt;: VIDA.AbstractTemplate</code></pre><p>Abstract type for taking two templates composing them in some manner and returning a new template.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/templates/templates.jl#LL68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.ImageTemplate" href="#VIDA.ImageTemplate"><code>VIDA.ImageTemplate</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type for an image template. This takes an EHTImage or any image object and creates a template out of it. The parameters of the image are the center of the image <code>x0</code>, <code>y0</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>x0</code></p></li><li><p><code>y0</code></p></li><li><p><code>itp</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/templates/image.jl#LL181-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.LogSpiral" href="#VIDA.LogSpiral"><code>VIDA.LogSpiral</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Template type for a logarithmic spiral segment</p><p><strong>Fields</strong></p><ul><li><p><code>r0</code></p><p>Radius of the spiral peak brightness</p></li><li><p><code>κ</code></p><p>Unit curvature of the logarithmic spiral</p></li><li><p><code>σ</code></p><p>thickness of the Gaussian spiral arm</p></li><li><p><code>δϕ</code></p><p>Azimuthal extent of the spiral arm</p></li><li><p><code>ξ</code></p><p>peak brightness location</p></li><li><p><code>x0</code></p><p>x location of disk center in μas</p></li><li><p><code>y0</code></p><p>y location of disk center in μas</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/templates/image.jl#LL121-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.Constant" href="#VIDA.Constant"><code>VIDA.Constant</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Constant &lt;: VIDA.AbstractImageTemplate</code></pre><p>An constant template.</p><p><strong>Details</strong></p><p>Defines an image that just has constant flux. This is very useful for soaking up low levels of flux in image reconstructions that can bias the results.</p><p>Since images or normalized to unity, this means the <code>Constant</code> template has no additional parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/templates/image.jl#LL234-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.Disk" href="#VIDA.Disk"><code>VIDA.Disk</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Disk &lt;: VIDA.AbstractImageTemplate</code></pre><p>A smoothed disk model</p><p><strong>Details</strong></p><p>Defines a template for an image that has a smoothed disk model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/templates/image.jl#LL250-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.AsymGaussian" href="#VIDA.AsymGaussian"><code>VIDA.AsymGaussian</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct AsymGaussian &lt;: VIDA.AbstractImageTemplate</code></pre><p>An asymmetric Gaussian blob.</p><p><strong>Details</strong></p><p>Defines a asymmetric Gaussian image. This is useful if the image has some non-ring emission in the and you need to soak up some of the flux.</p><p>The parameters of the model follow very closely to those used in Themis. The Gaussian size <code>σ</code> is given by     σ = √(σxσy)     τ = 1-σy/σx, where σx,σy are the semi-major,minor axis lenght respectively. This is similar to how the asymmetry for the <code>EllipticalGaussianRing</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>σ</code></p><p>Gaussian size in μas</p></li><li><p><code>τ</code></p><p>Gaussian asymmetry</p></li><li><p><code>ξ</code></p><p>Gaussian orientation in radians measured north of east</p></li><li><p><code>x0</code></p><p>x position of Gaussian center in μas</p></li><li><p><code>y0</code></p><p>y position of Gaussian center in μas</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/templates/image.jl#LL293-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.GaussianRing" href="#VIDA.GaussianRing"><code>VIDA.GaussianRing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct GaussianRing &lt;: VIDA.AbstractImageTemplate</code></pre><p>Symmetric gaussian ring template. This is the most basic template and just attempts to recover a location <code>x0</code>,<code>y0</code>, radius <code>r0</code> and thickness <code>σ</code> from some image.</p><p><strong>Fields</strong></p><ul><li><p><code>r0</code></p><p>Radius of Gaussian ring in μas</p></li><li><p><code>σ</code></p><p>Standard deviation of Gaussian ring in μas</p></li><li><p><code>x0</code></p><p>x location of the center of the Gaussian ring in μas</p></li><li><p><code>y0</code></p><p>y location of the center of the Gaussian ring in μas</p></li></ul><p><strong>Example</strong></p><pre><code class="language-julia">GaussianRing(r0=20.0,σ=5.0,x0=0.0,y0=-10.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/templates/image.jl#LL342-L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.SlashedGaussianRing" href="#VIDA.SlashedGaussianRing"><code>VIDA.SlashedGaussianRing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct SlashedGaussianRing &lt;: VIDA.AbstractImageTemplate</code></pre><p>Implements the slashed gaussian ring template, that uses a cosine to symmetrically implement the slash. While this is marginally more complicated that a linear slash, it has a number of benefits such as mainting the azimuthal and smooth structure of the image.</p><p><strong>Fields</strong></p><ul><li><p><code>r0</code></p><p>Radius of the ring in μas</p></li><li><p><code>σ</code></p><p>Standard deviation of Gaussian ring in μas</p></li><li><p><code>s</code></p><p>Slash strength of Gaussiang ring. 0 means no slash</p></li><li><p><code>ξ</code></p><p>Rotation angle in radians of slash direction, measured north of west</p></li><li><p><code>x0</code></p><p>x position of the center of the ring in μas</p></li><li><p><code>y0</code></p><p>y position of the center of the ring in μas</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/templates/image.jl#LL466-L476">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.EllipticalGaussianRing" href="#VIDA.EllipticalGaussianRing"><code>VIDA.EllipticalGaussianRing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct EllipticalGaussianRing &lt;: VIDA.AbstractImageTemplate</code></pre><p>Implements the elliptical gaussian ring template. Where the ellipticity <code>tau</code> is defined as one minus ratio between the semi-minor and semi-major axis.</p><p><strong>Details</strong></p><p>Adds ellipticity to the ring. The radius <code>r0</code> of the ring is now defined as the geometric mean of the semi-major (a) and semi-minor (b) axis lengths i.e.</p><p>r0 = √(a*b).</p><p>The ellipticity <code>τ</code> is given by τ = 1-b/a.</p><p><strong>Fields</strong></p><ul><li><p><code>r0</code></p><p>Radius of the Gaussian ring</p></li><li><p><code>σ</code></p><p>Standard deviation of the width of the Gaussian ring</p></li><li><p><code>τ</code></p><p>Asymmetry of the Gaussian ring defined as <span>$1-b/a$</span></p></li><li><p><code>ξ</code></p><p>Asymmetry orientation in radians measured north of east</p></li><li><p><code>x0</code></p><p>x position of the center of the ring in μas</p></li><li><p><code>y0</code></p><p>y position of the center of the ring in μas</p></li></ul><p><strong>Notes</strong></p><p>There is no normalization since the ellipticity makes it impossible to normalize analytically. In fact the distance from the ellipse is implemented numerically using an algorithm adapted from <a href="https://github.com/0xfaded/ellipse_demo/issues/1#issuecomment-405078823">git</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/templates/image.jl#LL519-L540">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.TIDAGaussianRing" href="#VIDA.TIDAGaussianRing"><code>VIDA.TIDAGaussianRing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct TIDAGaussianRing &lt;: VIDA.AbstractImageTemplate</code></pre><p>Creates the template from the Paper I am writing. It is a combination of the elliptical and slashed gaussian ring. The slash and the semi-major axis are either aligned if the slash parameter <code>s</code>&gt;0 or antialigned if <code>s</code>&lt;0.</p><p><strong>Details</strong></p><p>Adds ellipticity to the ring. The radius <code>r0</code> of the ring is now defined as the geometric mean of the semi-major (a) and semi-minor (b) axis lengths i.e.</p><p>r0 = √(a*b).</p><p>The ellipticity <code>τ</code> is given by τ = 1-b/a.</p><p><strong>Fields</strong></p><ul><li><p><code>r0</code></p><p>Radius of the Gaussian ring</p></li><li><p><code>σ</code></p><p>Standard deviation of the width of the Gaussian ring</p></li><li><p><code>τ</code></p><p>Asymmetry of the Gaussian ring defined as <span>$1-b/a$</span></p></li><li><p><code>s</code></p><p>Slash of Gaussian ring.</p></li><li><p><code>ξ</code></p><p>Slash/Asymmetry orientation in radians measured north of east</p></li><li><p><code>x0</code></p><p>x position of the center of the ring in μas</p></li><li><p><code>y0</code></p><p>y position of the center of the ring in μas</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/templates/image.jl#LL577-L594">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.GeneralGaussianRing" href="#VIDA.GeneralGaussianRing"><code>VIDA.GeneralGaussianRing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct GeneralGaussianRing &lt;: VIDA.AbstractImageTemplate</code></pre><p>Creates the most general elliptical slashed gaussian ring model. It is a combination of the elliptical and slashed gaussian ring. The direction of the slash and the ellipticity are not aligned or anti-aligned like with the TIDAGaussianRing type.</p><p><strong>Details</strong></p><p>Adds ellipticity to the ring. The radius <code>r0</code> of the ring is now defined as the geometric mean of the semi-major (a) and semi-minor (b) axis lengths i.e.</p><p>r0 = √(a*b).</p><p>The ellipticity <code>τ</code> is given by τ = 1-b/a.</p><p><strong>Fields</strong></p><ul><li><p><code>r0</code></p><p>Radius of the Gaussian ring</p></li><li><p><code>σ</code></p><p>Standard deviation of the width of the Gaussian ring</p></li><li><p><code>τ</code></p><p>Asymmetry of the Gaussian ring defined as <span>$1-b/a$</span></p></li><li><p><code>ξτ</code></p><p>Asymmetry orientation in radians, measured north of east</p></li><li><p><code>s</code></p><p>Slash of Gaussian ring.</p></li><li><p><code>ξs</code></p><p>Slash orientation in radians measured north of east</p></li><li><p><code>x0</code></p><p>x position of the center of the ring in μas</p></li><li><p><code>y0</code></p><p>y position of the center of the ring in μas</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/templates/image.jl#LL648-L664">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.SymCosineRing" href="#VIDA.SymCosineRing"><code>VIDA.SymCosineRing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct SymCosineRing{N, M} &lt;: VIDA.AbstractImageTemplate</code></pre><p>Extrememly flexible symmetric ring model. The thickness is modeled as a cosine expansion with <code>N</code> terms and the slash by a expansion with <code>M</code> terms.</p><p><strong>Details</strong></p><p>The ring is forced to be symmetric for a significant speed boost over CosineRing. The thickness of the ring is modeled by a cosine expansion in azimuthal angle. <code>N</code> specifies the number of cosine modes to fit, where the first mode is the constant thickness portion and so has no corresponding angle. The slash is modeled as a separate cosine expansion, with <code>M</code> terms. Here the zero order term is forced to be unity, so <code>M</code> defines the <code>M</code> additional terms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/templates/image.jl#LL23-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.CosineRing" href="#VIDA.CosineRing"><code>VIDA.CosineRing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct CosineRing{N, M} &lt;: VIDA.AbstractImageTemplate</code></pre><p>Extrememly flexible ring model. The thickness is modeled as a cosine expansion with <code>N</code> terms and the slash by a expansion with <code>M</code> terms.</p><p><strong>Details</strong></p><p>The ring is allowed to be elliptical. The thickness of the ring is modeled by a cosine expansion in azimuthal angle. <code>N</code> specifies the number of cosine modes to fit, where the first mode is the constant thickness portion and so has no corresponding angle. The slash is modeled as a separate cosine expansion, with <code>M</code> terms. Here the zero order term is forced to be unity, so <code>M</code> defines the <code>M</code> additional terms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/templates/image.jl#LL714-L729">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.AddTemplate" href="#VIDA.AddTemplate"><code>VIDA.AddTemplate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct AddTemplate{T1&lt;:VIDA.AbstractTemplate, T2&lt;:VIDA.AbstractTemplate} &lt;: VIDA.AbstractCompositeTemplate</code></pre><p>Combines two templates together into one object. Since addition is assoiciative this can actually we used to hold multiple different templates.</p><p><strong>Details</strong></p><p>Overloads the Base.:+ function so you can easily add two templates together.</p><p><strong>Example</strong></p><pre><code class="language-julia">θ1 = GaussianRing(10,5,0,0)
θ2 = SlashedGaussianRing(15,5,0.5,π/4,0,0)
θ12 = θ1+θ2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/templates/composite.jl#LL4-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.MulTemplate" href="#VIDA.MulTemplate"><code>VIDA.MulTemplate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct MulTemplate{T&lt;:VIDA.AbstractTemplate, S&lt;:Number} &lt;: VIDA.AbstractModifierTemplate</code></pre><p>Multiplies template by a constant. This is useful when combining with AddTemplate since it will change the relative weights of each template.</p><p><strong>Details</strong></p><p>Overloads the Base.:* function so you can easily multiple a template by a number.</p><p><strong>Example</strong></p><pre><code class="language-julia">θ = GaussianRing(15,5,0.0,0.0)
2*θ</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/templates/modifiers.jl#LL133-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.StretchMod" href="#VIDA.StretchMod"><code>VIDA.StretchMod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StretchMod(θ::AbstractTemplate, τ)</code></pre><p>Modifies a filter by stretching it in the x-direction by 1/√(1-τ) and y-direction by sqrt(1-τ). Typically call the stretch function instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/templates/modifiers.jl#LL6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.stretch" href="#VIDA.stretch"><code>VIDA.stretch</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">stretch(m, τ)
</code></pre><p>Stretch the template m, using the τ factor. This will stretch the x-axis by 1/√(1-τ) and y-axis by √(1-τ).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/templates/modifiers.jl#LL46-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.RotateMod" href="#VIDA.RotateMod"><code>VIDA.RotateMod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RotateMod(θ::AbstractTemplate, ξ)</code></pre><p>Modifies a filter by rotating it using the rotation matrix with angle ξ. Typically do not call this function directly but instread the rotate function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/templates/modifiers.jl#LL70-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.rotate" href="#VIDA.rotate"><code>VIDA.rotate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rotate(m, ξ)
</code></pre><p>Rotate the template m by ξ. This rotates north of east.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/templates/modifiers.jl#LL100-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.stretchrotate" href="#VIDA.stretchrotate"><code>VIDA.stretchrotate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">stretchrotate(m, τ, ξ)
</code></pre><p>Stretch and then rotate a template producing a modified template. This is equivalent to rotate(stretch(m, τ), ξ).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/templates/modifiers.jl#LL122-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size-Tuple{T} where T&lt;:VIDA.AbstractTemplate" href="#Base.size-Tuple{T} where T&lt;:VIDA.AbstractTemplate"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">size(f::AbstractTemplate)</code></pre><p>Get the number of parameters for the template f</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/templates/templates.jl#LL10-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.unpack" href="#VIDA.unpack"><code>VIDA.unpack</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">unpack(θinit)
</code></pre><p>Unpacks the parameters of the template <code>θ</code></p><p>Returns the parameters in a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/templates/image.jl#LL1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.stack" href="#VIDA.stack"><code>VIDA.stack</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">stack(θ, θ1)
</code></pre><p>Stacks templates together so you can easily combine multiple templates. It does this by calling the :+ and :* method. Every template added will include an additional parameter that controls the relative weight of each template.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/templates/composite.jl#LL52-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.split" href="#Base.split"><code>Base.split</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">split(θ)
</code></pre><p>Splits the template into an array with its subcomponents so you can easily access them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/templates/composite.jl#LL62-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.template_image" href="#VIDA.template_image"><code>VIDA.template_image</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">template_image(θ, npix, xlim, ylim)
</code></pre><p>Creates an npix×npix rasterized image of the template <code>θ</code> with limits <code>xlim</code> and <code>ylim</code></p><p>Returns the tuple (xitr,yitr,image) where xitr,yitr are the iterators defining the pixel locations (which are centered) and the rasterized image,  in Jy/μas^2.</p><p><strong>Note</strong></p><p>I use the pixel size definition field<em>of</em>view/npix, but the image is evaluated at the pixel centers.</p><p>We also use the astronomer orientation and ordering.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/templates/utils.jl#LL1-L16">source</a></section></article><h2 id="Images"><a class="docs-heading-anchor" href="#Images">Images</a><a id="Images-1"></a><a class="docs-heading-anchor-permalink" href="#Images" title="Permalink"></a></h2><p>VIDA has an image interface that reads in images using the FITS standard.</p><article class="docstring"><header><a class="docstring-binding" id="VIDA.AbstractImage" href="#VIDA.AbstractImage"><code>VIDA.AbstractImage</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An abstact type that acts as a wrapper for image objects used in astronomy.</p><p>This is the top of the castle for images and will be rarely touched. Basically unless you don&#39;t want to use fits images this will not be used</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/images.jl#LL1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.AbstractFitsImage" href="#VIDA.AbstractFitsImage"><code>VIDA.AbstractFitsImage</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An absract image that will hold a fits image after being created or parsed in. This will form the basis for most astronomical images that are defined.</p><p>The defines an interface to the FITS image methods below. In the future I may change this to use the traits interfaces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/images.jl#LL10-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.EHTImage" href="#VIDA.EHTImage"><code>VIDA.EHTImage</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct EHTImage{F, T&lt;:AbstractArray{F, 2}} &lt;: VIDA.AbstractFitsImage{F, T&lt;:AbstractArray{F, 2}}</code></pre><p><strong>Details</strong></p><p>The trait is to hold a EHT image tyically in matrix form. Namely the trait will typically be Matrix{Float64}.</p><p><code>nx</code> is the number of pixels in the x or RA direction <code>ny</code> is the number of pixels in the y or DEC direction <code>psize_x</code>, <code>psize_y</code> are the pixel sizes in the x and y direction <code>source</code> is the source we are looking at e.g. M87 <code>ra</code>,<code>dec</code> are the sources RA and DEC in J2000 coordinates using degrees <code>wavelength</code> is the wavelength of the image. <code>mjd</code> is the Modified Julian Date of the observation. <code>img</code> is the actual pixeled image in Jy/pixel</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/images.jl#LL25-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.load_fits" href="#VIDA.load_fits"><code>VIDA.load_fits</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">load_fits(fits_name)
</code></pre><p>where <code>fits_name</code> should be a fits file generated using ehtim</p><p><strong>Details</strong></p><p>This reads in a fits file that is more robust to the various imaging algorithms in the EHT, i.e. is works with clean, smili, eht-imaging.</p><p>The function returns an EHTImage object that contains the relevant image and parameters extracted from the fits file. It also ensures that we are astronomers and that the image using sky-left coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/images.jl#LL182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.save_fits" href="#VIDA.save_fits"><code>VIDA.save_fits</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">save_fits(image::EHTImage, fname::String)</code></pre><p>Save the <code>image</code> as a fits object with filename <code>fname</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/images.jl#LL265-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.centroid" href="#VIDA.centroid"><code>VIDA.centroid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">centroid(img)
</code></pre><p>Finds the centroid or center of light of the <code>img</code> in μas.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/images.jl#LL335-L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.inertia" href="#VIDA.inertia"><code>VIDA.inertia</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">inertia(img)
inertia(img, center)
</code></pre><p>Find the image moment of inertia or <strong>second moment</strong></p><p><strong>Notes</strong></p><p>If <code>center=true</code> then we find the central second moment, or the second cumulant of the image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/images.jl#LL361-L368">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.pixelloc" href="#VIDA.pixelloc"><code>VIDA.pixelloc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pixelloc(img)
</code></pre><p>Returns two iterators (ra,dec) that give the locations of the <code>img</code> pixels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/images.jl#LL135-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.flux-Tuple{EHTImage}" href="#VIDA.flux-Tuple{EHTImage}"><code>VIDA.flux</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">flux(img)
</code></pre><p>Finds the image flux of an EHTImage <code>img</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/images.jl#LL403-L406">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.rescale-Tuple{EHTImage, Any, Any, Any}" href="#VIDA.rescale-Tuple{EHTImage, Any, Any, Any}"><code>VIDA.rescale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rescale(img::EHTImage, npix, xlim, ylim)</code></pre><p><strong>Inputs</strong></p><ul><li>img::EHTImage : Image you want to rescale</li><li>npix : Number of pixels in x and y direction</li><li>xlim : Tuple with the limits of the image in the RA in μas</li><li>ylim : Tuple with the limits of the image in DEC in μas</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/images.jl#LL421-L428">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.blur-Tuple{EHTImage, Any}" href="#VIDA.blur-Tuple{EHTImage, Any}"><code>VIDA.blur</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">blur(img, fwhm)
</code></pre><p>Blurs the <code>img</code> with a gaussian kernel with fwhm in μas. If <code>fwhm</code> is a scalar then the kernel is assumed to be symmetric, otherwise you the first entry is the fwhm in the EW direction and second the NS direction.</p><p>Returns the blurred image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/images.jl#LL448-L456">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Base.size(img::EHTImage)</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="VIDA.clipimage" href="#VIDA.clipimage"><code>VIDA.clipimage</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">clipimage(clip, image)
clipimage(clip, image, mode)
</code></pre><p>Clips the image <code>im</code> according to the value clip. There are two modes for image clipping:     - <code>:relative</code> which zeros the pixels whose intensity are below <code>clip</code> relative to the max.     - <code>:absolute</code> which zeros the pixels whose intensity is below <code>clip</code> in Jy/pixel</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/images.jl#LL156-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.field_of_view" href="#VIDA.field_of_view"><code>VIDA.field_of_view</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">field_of_view(img)
</code></pre><p>Finds the field of view of an EHTImage. Return a w element tuple with the field of view in the x and y direction</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/images.jl#LL411-L415">source</a></section></article><h2 id="Movies"><a class="docs-heading-anchor" href="#Movies">Movies</a><a id="Movies-1"></a><a class="docs-heading-anchor-permalink" href="#Movies" title="Permalink"></a></h2><p>VIDA also has a movie interface using hdf5. Note that movies are more than just a list of images. We also use an interpolation between frames.</p><article class="docstring"><header><a class="docstring-binding" id="VIDA.AbstractMovie" href="#VIDA.AbstractMovie"><code>VIDA.AbstractMovie</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractMovie</code></pre><p>Creates an abstract movie class</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/movies.jl#LL1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.EHTMovie" href="#VIDA.EHTMovie"><code>VIDA.EHTMovie</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct EHTMovie{F, T&lt;:(Interpolations.AbstractExtrapolation{F, N, ITPT, IT} where {N, ITPT, IT})} &lt;: VIDA.AbstractMovie</code></pre><p><strong>Details</strong></p><p>The type is to hold a EHT movie. The dimension of the movie array is assumed to be in the form DEC,RA,Time.</p><p><code>nx</code> is the number of pixels in the x or RA direction <code>ny</code> is the number of pixels in the y or DEC direction <code>psize_x</code>, <code>psize_y</code> are the pixel sizes in the x and y direction <code>source</code> is the source we are looking at e.g. M87 <code>ra</code>,<code>dec</code> are the sources RA and DEC in J2000 coordinates using degrees <code>wavelength</code> is the wavelength of the image. <code>mjd</code> is the Modified Julian Date of the observation. <code>frames</code> is the interpolation object that hold the movie frames</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/movies.jl#LL7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.load_hdf5" href="#VIDA.load_hdf5"><code>VIDA.load_hdf5</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">load_hdf5(filename; style)
</code></pre><p>Loads an hdf5 file where <code>filename</code> should be a HDF5 file.</p><p><strong>Details</strong></p><p>This reads in a hdf5 file and outputs and EHTMovie object.</p><p><strong>Notes</strong></p><p>Currently this only works with movies created by <em>ehtim</em>. SMILI uses a different format, as does Illinois, and every other group...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/movies.jl#LL177-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.save_hdf5" href="#VIDA.save_hdf5"><code>VIDA.save_hdf5</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">save_hdf5(filename, mov; style)
</code></pre><p>Saves and hdf5 file where <code>filename</code> is the write out location. Currently style only works with ehtim, namely we save HDF5 files that only work with ehtim.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/movies.jl#LL196-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.join_frames" href="#VIDA.join_frames"><code>VIDA.join_frames</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">join_frames(times, images)
</code></pre><p>Joins an array of EHTImages at specified times to form an EHTMovie object.</p><p><strong>Inputs</strong></p><ul><li>times: An array of times that the image was created at</li><li>images: An array of EHTImage objects</li></ul><p><strong>Outputs</strong></p><p>EHTMovie object</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/movies.jl#LL64-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.get_times" href="#VIDA.get_times"><code>VIDA.get_times</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_times(mov)
</code></pre><p>Returns the times that the movie object <code>mov</code> was created at. This does not have to be uniform in time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/movies.jl#LL95-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.get_frames" href="#VIDA.get_frames"><code>VIDA.get_frames</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_frames(mov)
</code></pre><p>Gets all the frames of the movie object <code>mov</code>. This returns a array of <code>EHTImage</code> objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/movies.jl#LL124-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.get_image" href="#VIDA.get_image"><code>VIDA.get_image</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_image(mov, t)
</code></pre><p>Gets the frame of the movie object <code>mov</code> at the time t. This returns an <code>EHTImage</code> object at the requested time. The returned object is found by linear interpolation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/movies.jl#LL105-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.flux-Tuple{EHTMovie, Any}" href="#VIDA.flux-Tuple{EHTMovie, Any}"><code>VIDA.flux</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">flux(mov, t)
</code></pre><p>Returns the flux of the <code>mov</code> at the times <code>time</code> in fractional hours</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/movies.jl#LL133-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.blur-Tuple{EHTMovie, Any}" href="#VIDA.blur-Tuple{EHTMovie, Any}"><code>VIDA.blur</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">blur(mov, fwhm)
</code></pre><p>Blurs the <code>mov</code> with a gaussian kernel with fwhm in μas. If <code>fwhm</code> is a scalar then the kernel is assumed to be symmetric, otherwise you the first entry is the fwhm in the EW direction and second the NS direction.</p><p>Returns the blurred movie.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/movies.jl#LL143-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.rescale-Tuple{EHTMovie, Any, Any, Any}" href="#VIDA.rescale-Tuple{EHTMovie, Any, Any, Any}"><code>VIDA.rescale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rescale(mov::EHTMovie, npix, xlim, ylim)</code></pre><p><strong>Inputs</strong></p><ul><li>mov::EHTMovie : Movie you want to rescale</li><li>npix : Number of pixels in x and y direction</li><li>xlim : Tuple with the limits of the image in the RA</li><li>ylim : Tuple with the limits of the image in DEC</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/movies.jl#LL159-L166">source</a></section></article><h2 id="Divergences"><a class="docs-heading-anchor" href="#Divergences">Divergences</a><a id="Divergences-1"></a><a class="docs-heading-anchor-permalink" href="#Divergences" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="VIDA.AbstractDivergence" href="#VIDA.AbstractDivergence"><code>VIDA.AbstractDivergence</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractDivergence</code></pre><p>An abstract class for a divergence of a function. This expects that a subtype has a field with an EHTImage object and a flux type. The struct is then assumed to be a <strong>functor</strong> and have a function that computes the divergence of the image and a template.</p><p>For example</p><pre><code class="language-julia">    struct MyDiv{T,F,S} &lt;: AbstractDivergence
        img::EHTImage{T,F}
        flux::S
    end
    function (bh::MyDiv)(θ::AbstractTemplate)
        ...
    end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/divergences.jl#LL2-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.Bhattacharyya" href="#VIDA.Bhattacharyya"><code>VIDA.Bhattacharyya</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Bhattacharyya{T&lt;:EHTImage, S} &lt;: VIDA.AbstractDivergence</code></pre><p>Type for the Bhattacharyya divergence. It constructed from an <code>EHTImage</code> i.e. data. Additionally to evaluate the divergence we use a functor approach where if θ is your</p><p><strong>Details</strong></p><p>This computes the Bhattacharyya divergence which is related to Hellinger distance between two distributions. In fact, they are both minimized at the same point. The Bhattacharyya divergence is defined as</p><p class="math-container">\[Bh(f_\theta||\hat{I}) = -\log\int \sqrt{f_\theta(x,y)\hat{I}(x,y)}dxdy,\]</p><p>where <span>$\hat{I}$</span> is defined as the image normalized to unit flux.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/divergences.jl#LL23-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.KullbackLeibler" href="#VIDA.KullbackLeibler"><code>VIDA.KullbackLeibler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct KullbackLeibler{T, S} &lt;: VIDA.AbstractDivergence</code></pre><p>Type for the KL divergence. It constructed from an <code>EHTImage</code> i.e. data. Additionally to evaluate the divergence we use a functor approach where if θ is your</p><p><strong>Details</strong></p><p>This computes the KL divergence which is related to Hellinger distance between two distributions. In fact, they are both minimized at the same point. The Bhattacharyya divergence is defined as</p><p class="math-container">\[KL(f_\theta||\hat{I}) = -\log\int f_{\theta}(x,y)\log
        \left(\frac{f_{\theta}(x,y)}{\hat{I}(x,y)}\right)dxdy,\]</p><p>where <span>$\hat{I}$</span> is defined as the image normalized to unit flux.</p><p>This struct is also a functor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/divergences.jl#LL72-L89">source</a></section></article><h2 id="Extractor"><a class="docs-heading-anchor" href="#Extractor">Extractor</a><a id="Extractor-1"></a><a class="docs-heading-anchor-permalink" href="#Extractor" title="Permalink"></a></h2><p>This defines the interface to the optimizers that can find the optimal template for a given image.</p><article class="docstring"><header><a class="docstring-binding" id="VIDA.Optimizer" href="#VIDA.Optimizer"><code>VIDA.Optimizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type Optimizer</code></pre><p>Abstract optimizer class that defines the optimizer to use. This is the interface I&#39;ll need to define all the different optimizer classes below.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/extractor.jl#LL1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.BBO" href="#VIDA.BBO"><code>VIDA.BBO</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct BBO &lt;: VIDA.Optimizer</code></pre><p>Defines the interface for the BlackBoxOptim interface. This requires that the user to have imported the BlackBoxOptim package.</p><p><strong>Fields</strong></p><ul><li>popsize: The population size DEFAULT 64</li><li>maxevals: The maximum number of times to evaluate the divergence before terminiation.</li><li>tracemode: The output option. Default is silent, i.e. no output.</li></ul><p>Other options are <code>:compact</code> and <code>:verbose</code></p><p><strong>Notes</strong></p><p>This uses the default BlackBoxOptim optimizer i.e. adaptive<em>de</em>rand<em>1</em>bin_radiuslimited. Currently other options aren&#39;t implemented since I found that this version tended to work the best.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/extractor.jl#LL9-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.CMAES" href="#VIDA.CMAES"><code>VIDA.CMAES</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct CMAES &lt;: VIDA.Optimizer</code></pre><p>Defines the interface for the LBFGS-B interface from the Optim.jl package. This requires that the user to have imported the <strong>CMAEvolutionStrategy package</strong>.</p><p>Typically I have found that this works very well. This the usual first optimizer to try.</p><p><strong>Fields</strong></p><ul><li><p><code>popsize</code></p><p>PopulationSize  Default: 64</p></li><li><p><code>cov_scale</code></p><p>Initial covariance scale  Default: 1.0</p></li><li><p><code>ftarget</code></p><p>target divergence values. <code>nothing</code> means there is no target  Default: nothing</p></li><li><p><code>xtol</code></p><p>xtol Default: nothing</p></li><li><p><code>ftol</code></p><p>ftol Default: 1.0e-11</p></li><li><p><code>maxevals</code></p><p>maximum number of divergence evals, nothing means run until termination Default: nothing</p></li><li><p><code>verbosity</code></p><p>verbosity of output Default: 1</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/extractor.jl#LL52-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.Opt" href="#VIDA.Opt"><code>VIDA.Opt</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Opt{O&lt;:Optim.AbstractConstrainedOptimizer} &lt;: VIDA.Optimizer</code></pre><p>Defines the interface for the LBFGS-B interface from the Optim.jl package. This requires that the user to have imported the <strong>Optim package</strong>.</p><p><strong>Fields</strong></p><ul><li><p><code>opt</code></p></li><li><p><code>options</code></p><p>Default: Optim.Options()</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/extractor.jl#LL34-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.ExtractProblem" href="#VIDA.ExtractProblem"><code>VIDA.ExtractProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ExtractProblem{T&lt;:AbstractDivergence, S&lt;:AbstractTemplate}</code></pre><p>Defines a feature extraction problem to minimize, with an abstract filte and an abstract divergence. This is needed to interface with the extractor minimizer, which will minimize the divergence to find the optimal template.</p><p><strong>Fields</strong></p><ul><li><p><code>div</code></p><p>Divergence function to minimize</p></li><li><p><code>θinit</code></p><p>Initial location of the optimizer</p></li><li><p><code>θlower</code></p><p>Lower bound of the search region</p></li><li><p><code>θupper</code></p><p>Upper bound of the search region</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/extractor.jl#LL81-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.extractor" href="#VIDA.extractor"><code>VIDA.extractor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">extractor(prob::ExtractProblem, optimizer::Optimizer)</code></pre><p>This extracts the optimal template defined by the <code>prob</code> problem. This will minimize the divergence in prob and return the optimal template and minimum divergence in a tuple.</p><p><code>optimizer</code> is one of VIDA&#39;s optimizer types. Typically I would recommend the BBO() optimizer</p><p><strong>Examples</strong></p><pre><code class="language-julia">    θopt, divmin = extractor(prob, BBO())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/extractor.jl#LL128-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VIDA.threaded_extractor" href="#VIDA.threaded_extractor"><code>VIDA.threaded_extractor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">threaded_extractor(nstart::Int, prob::ExtractProblem, optimizer::Optimizer)</code></pre><p>A threaded multi-start version of the extractor method. This will run <code>nstart</code> instances of extractor, where the initial location of chosen uniformly within the bounds defined in <code>prob</code>.</p><p><strong>Outputs</strong></p><p>This outputs the best template and minimum divergence of all the extractors run.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/extractor.jl#LL101-L109">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="VIDA.make_image" href="#VIDA.make_image"><code>VIDA.make_image</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">make_image(θ, npix, xlim, ylim; intensity, source, wavelength, ra, dec, mjd)
</code></pre><p>Creates an EHTImage type from the template type. The number of pixels in the image are given by <code>npix</code> and the field of view in μas in the x and y direction are given by <code>xlim</code> and <code>ylim</code>. The rest of the options are the default image characteristics</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/utils.jl#LL1-L10">source</a></section><section><div><pre><code class="language-julia">make_image(θ, npix, xlim, ylim, source_img; intensity)
</code></pre><p>Creates an EHTImage type from the template type. The number of pixels in the image are given by <code>npix</code> and the field of view in μas in the x and y direction are given by <code>xlim</code> and <code>ylim</code>. To define the source we use an <code>source_img</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/utils.jl#LL31-L39">source</a></section></article><h2 id="Visualizations"><a class="docs-heading-anchor" href="#Visualizations">Visualizations</a><a id="Visualizations-1"></a><a class="docs-heading-anchor-permalink" href="#Visualizations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="VIDA.triptic" href="#VIDA.triptic"><code>VIDA.triptic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">triptic(img::EHTImage, template)</code></pre><p>Plots a triptic where the left panel is the <code>img</code> middle the <code>template</code> and the right a two cross-sections of the image and template</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ptiede/VIDA.jl/blob/9b15649049d4e9de05f1fa507ecc45bda68423d5/src/visualizations.jl#LL61-L66">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../generated/custom_template/">« Adding a Custom Template</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 15 May 2021 23:20">Saturday 15 May 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
